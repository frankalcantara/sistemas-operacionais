---
title: "Projetos"
---

## Cap√≠tulo: Gest√£o de Processos

### Projeto 2: Monitor de Hierarquia de Processos e An√°lise de Mem√≥ria

#### Compila√ß√£o **Linux** (GCC/Clang com C++23)

```bash
# Ubuntu/Debian
sudo apt update && sudo apt install build-essential

# Compila√ß√£o
g++ -std=c++23 -O2 -Wall -Wextra \
    -o system_monitor system_process_monitor.cpp

# Ou com Clang
clang++ -std=c++23 -O2 -Wall -Wextra \
    -o system_monitor system_process_monitor.cpp
```

#### Compila√ß√£o Windows (Visual Studio 2022)

```cmd
# Visual Studio Developer Command Prompt
cl /std:c++23 /EHsc /O2 system_process_monitor.cpp /Fe:system_monitor.exe

# Ou com MinGW-w64
g++ -std=c++23 -O2 -Wall -Wextra \
    -o system_monitor.exe system_process_monitor.cpp
```    

### Execu√ß√£o

```bash
# Linux
sudo ./system_monitor  # Requer privil√©gios para acessar alguns processos

# Windows
# Executar como Administrador para acesso completo
system_monitor.exe
```

#### C√≥digo

```cpp
/**
 * @file system_process_monitor.cpp
 * @brief Monitor Avan√ßado de Hierarquia de Processos + An√°lise de Mem√≥ria
 * @author Livro de **Sistemas Operacionais** 
 * @version 1.0
 * @date 2025
 * 
 * Sistema cross-platform que demonstra as diferen√ßas fundamentais
 * entre arquiteturas de processo **Linux** e Windows, combinando an√°lise de
 * hierarquia, memory layout e intera√ß√µes kernel-user.
 */

#include <iostream>
#include <vector>
#include <string>
#include <memory>
#include <unordered_map>
#include <variant>
#include <optional>
#include <chrono>
#include <format>
#include <ranges>
#include <algorithm>
#include <fstream>
#include <sstream>
#include <thread>
#include <random>

#ifdef _WIN32
    #include <windows.h>
    #include <psapi.h>
    #include <tlhelp32.h>
    #include <winternl.h>
#else
    #include <unistd.h>
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <dirent.h>
    #include <filesystem>
    #include <cctype>
#endif

/**
 * @brief Enumera√ß√µes e tipos fundamentais
 */
enum class Platform { **Linux**, Windows, Unknown };
enum class ProcessType { 
    User, KernelThread, SystemProcess, Driver, Service, Unknown 
};
enum class PrivilegeLevel { 
    System, Administrator, User, Low, Unknown 
};
enum class AddressingMode { 
    Bit32, Bit48, Bit64 
};

using pid_t = uint32_t;

/**
 * @brief Estruturas de dados espec√≠ficas por plataforma
 */
struct LinuxSpecific {
    bool is_kthread{false};
    std::string cgroup_path;
    uid_t effective_uid{0};
    std::vector<std::string> capabilities;
    bool has_vdso_mapping{false};
    std::string kernel_function;  // Para kthreads
};

struct WindowsSpecific {
    uint32_t session_id{0};
    std::string elevation_type;
    std::vector<std::string> privileges;
    bool is_protected_process{false};
    uint32_t integrity_level{0};
    std::string image_path;
};

/**
 * @brief Informa√ß√µes de regi√£o de mem√≥ria
 */
struct MemoryRegion {
    uintptr_t start_address{0};
    uintptr_t end_address{0};
    std::string permissions;
    std::string region_type;
    bool is_kernel_accessible{false};
    std::optional<std::string> backing_file;
    size_t size_kb{0};
    
    /**
     * @brief Calcula o tamanho da regi√£o
     */
    size_t getSize() const {
        return end_address - start_address;
    }
};

/**
 * @brief Informa√ß√µes do espa√ßo de endere√ßamento virtual
 */
struct VirtualAddressSpace {
    uintptr_t user_space_start{0};
    uintptr_t user_space_end{0};
    uintptr_t kernel_space_start{0};
    uintptr_t kernel_space_end{0};
    bool kaslr_enabled{false};
    bool kpti_enabled{false};
    size_t page_size{4096};
    AddressingMode mode{AddressingMode::Bit64};
    
    /**
     * @brief Verifica se um endere√ßo est√° no espa√ßo do usu√°rio
     */
    bool isUserSpace(uintptr_t address) const {
        return address >= user_space_start && address <= user_space_end;
    }
    
    /**
     * @brief Verifica se um endere√ßo est√° no espa√ßo do kernel
     */
    bool isKernelSpace(uintptr_t address) const {
        return address >= kernel_space_start && address <= kernel_space_end;
    }
};

/**
 * @brief Layout completo de mem√≥ria
 */
struct MemoryLayout {
    std::vector<MemoryRegion> regions;
    VirtualAddressSpace vas_info;
    size_t total_virtual_memory{0};
    size_t total_resident_memory{0};
    size_t kernel_accessible_memory{0};
};

/**
 * @brief Informa√ß√µes completas de um processo
 */
struct ProcessInfo {
    pid_t pid{0};
    pid_t parent_pid{0};
    std::string name;
    std::string command_line;
    ProcessType type{ProcessType::Unknown};
    PrivilegeLevel privilege{PrivilegeLevel::Unknown};
    
    // Memory specifics
    uintptr_t virtual_base{0};
    size_t virtual_size{0};
    size_t resident_memory{0};
    bool is_kernel_space_accessible{false};
    
    // Platform-specific data
    std::variant<LinuxSpecific, WindowsSpecific> platform_data;
    
    // Timing and resource usage
    std::chrono::milliseconds cpu_time{0};
    size_t syscall_count{0};
    double kernel_time_percentage{0.0};
    
    /**
     * @brief Obt√©m dados espec√≠ficos do Linux
     */
    const LinuxSpecific* getLinuxData() const {
        return std::get_if<LinuxSpecific>(&platform_data);
    }
    
    /**
     * @brief Obt√©m dados espec√≠ficos do Windows
     */
    const WindowsSpecific* getWindowsData() const {
        return std::get_if<WindowsSpecific>(&platform_data);
    }
};

/**
 * @brief Interface abstrata para opera√ß√µes espec√≠ficas da plataforma
 */
class PlatformInterface {
public:
    virtual ~PlatformInterface() = default;
    virtual std::vector<ProcessInfo> enumerateProcesses() = 0;
    virtual MemoryLayout analyzeMemoryLayout(pid_t pid) = 0;
    virtual VirtualAddressSpace getVirtualAddressSpace() = 0;
    virtual ProcessType determineProcessType(const ProcessInfo& info) = 0;
    virtual std::string getPlatformName() const = 0;
};

/**
 * @brief Implementa√ß√£o espec√≠fica para Linux
 */
class LinuxPlatform : public PlatformInterface {
private:
    /**
     * @brief Verifica se uma string √© num√©rica (PID)
     */
    bool isNumeric(const std::string& str) const {
        return !str.empty() && std::ranges::all_of(str, ::isdigit);
    }
    
    /**
     * @brief L√™ informa√ß√µes de status do processo
     */
    ProcessInfo readProcessStatus(pid_t pid) const {
        ProcessInfo info;
        info.pid = pid;
        
        // L√™ nome do processo
        std::ifstream comm_file(std::format("/proc/{}/comm", pid));
        if (comm_file.is_open()) {
            std::getline(comm_file, info.name);
            if (!info.name.empty() && info.name.back() == '\n') {
                info.name.pop_back();
            }
        }
        
        // L√™ linha de comando
        std::ifstream cmdline_file(std::format("/proc/{}/cmdline", pid));
        if (cmdline_file.is_open()) {
            std::string cmdline;
            std::getline(cmdline_file, cmdline, '\0');
            info.command_line = cmdline.empty() ? "<n√£o dispon√≠vel>" : cmdline;
        }
        
        // L√™ informa√ß√µes detalhadas do status
        std::ifstream status_file(std::format("/proc/{}/status", pid));
        std::string line;
        LinuxSpecific linux_data;
        
        while (status_file.is_open() && std::getline(status_file, line)) {
            std::istringstream iss(line);
            std::string key;
            iss >> key;
            
            if (key == "PPid:") {
                iss >> info.parent_pid;
            } else if (key == "Uid:") {
                iss >> linux_data.effective_uid;
            } else if (key == "VmSize:") {
                iss >> info.virtual_size;
            } else if (key == "VmRSS:") {
                iss >> info.resident_memory;
            }
        }
        
        // Detecta se √© kthread
        linux_data.is_kthread = (info.name.front() == '[' && info.name.back() == ']');
        if (linux_data.is_kthread) {
            linux_data.kernel_function = info.name.substr(1, info.name.length() - 2);
        }
        
        info.platform_data = linux_data;
        return info;
    }
    
public:
    std::vector<ProcessInfo> enumerateProcesses() override {
        std::vector<ProcessInfo> processes;
        
        try {
            for (const auto& entry : std::filesystem::directory_iterator("/proc")) {
                if (entry.is_directory()) {
                    std::string dirname = entry.path().filename().string();
                    
                    if (isNumeric(dirname)) {
                        pid_t pid = std::stoi(dirname);
                        auto info = readProcessStatus(pid);
                        if (!info.name.empty()) {
                            processes.push_back(std::move(info));
                        }
                    }
                }
            }
        } catch (const std::filesystem::filesystem_error& e) {
            std::cerr << "Erro ao acessar /proc: " << e.what() << std::endl;
        }
        
        return processes;
    }
    
    MemoryLayout analyzeMemoryLayout(pid_t pid) override {
        MemoryLayout layout;
        
        // L√™ /proc/[pid]/maps
        std::ifstream maps_file(std::format("/proc/{}/maps", pid));
        std::string line;
        
        while (std::getline(maps_file, line)) {
            std::istringstream iss(line);
            std::string address_range, permissions, offset, device, inode, pathname;
            
            iss >> address_range >> permissions >> offset >> device >> inode;
            std::getline(iss, pathname);
            
            // Parse address range
            size_t dash_pos = address_range.find('-');
            if (dash_pos != std::string::npos) {
                MemoryRegion region;
                region.start_address = std::stoull(address_range.substr(0, dash_pos), nullptr, 16);
                region.end_address = std::stoull(address_range.substr(dash_pos + 1), nullptr, 16);
                region.permissions = permissions;
                region.size_kb = region.getSize() / 1024;
                
                // Determina tipo da regi√£o
                if (!pathname.empty()) {
                    pathname.erase(0, pathname.find_first_not_of(" \t"));
                    if (pathname == "[heap]") {
                        region.region_type = "Heap";
                    } else if (pathname == "[stack]") {
                        region.region_type = "Stack";
                    } else if (pathname == "[vdso]") {
                        region.region_type = "vDSO";
                        // Detecta vDSO para an√°lise **Linux** espec√≠fica
                    } else if (pathname.starts_with("/")) {
                        region.region_type = "Mapped File";
                        region.backing_file = pathname;
                    } else {
                        region.region_type = "Special";
                        region.backing_file = pathname;
                    }
                } else {
                    region.region_type = "Anonym s";
                }
                
                layout.regions.push_back(region);
                layout.total_virtual_memory += region.size_kb;
                
                if (permissions.contains('r') || permissions.contains('w')) {
                    layout.total_resident_memory += region.size_kb;
                }
            }
        }
        
        layout.vas_info = getVirtualAddressSpace();
        return layout;
    }
    
    VirtualAddressSpace getVirtualAddressSpace() override {
        VirtualAddressSpace vas;
        
        // Configura√ß√£o padr√£o para **Linux** x86_64
        vas.user_space_start = 0x0000000000000000ULL;
        vas.user_space_end = 0x00007FFFFFFFFFFFULL;
        vas.kernel_space_start = 0xFFFF800000000000ULL;
        vas.kernel_space_end = 0xFFFFFFFFFFFFFFFFULL;
        vas.page_size = 4096;
        vas.mode = AddressingMode::Bit48;
        
        // Detecta KASLR
        std::ifstream cmdline("/proc/cmdline");
        std::string kernel_cmdline;
        if (cmdline.is_open()) {
            std::getline(cmdline, kernel_cmdline);
            vas.kaslr_enabled = kernel_cmdline.find("nokaslr") == std::string::npos;
        }
        
        // Detecta KPTI (Meltdown mitigation)
        std::ifstream cpuinfo("/proc/cpuinfo");
        std::string line;
        while (std::getline(cpuinfo, line)) {
            if (line.find("pti") != std::string::npos || 
                line.find("kaiser") != std::string::npos) {
                vas.kpti_enabled = true;
                break;
            }
        }
        
        return vas;
    }
    
    ProcessType determineProcessType(const ProcessInfo& info) override {
        const auto* linux_data = info.getLinuxData();
        if (!linux_data) return ProcessType::Unknown;
        
        if (linux_data->is_kthread) {
            return ProcessType::KernelThread;
        }
        
        if (linux_data->effective_uid == 0) {
            return ProcessType::SystemProcess;
        }
        
        return ProcessType::User;
    }
    
    std::string getPlatformName() const override {
        return "Linux";
    }
};

#ifdef _WIN32
/**
 * @brief Implementa√ß√£o espec√≠fica para Windows
 */
class WindowsPlatform : public PlatformInterface {
private:
    /**
     * @brief Obt√©m informa√ß√µes detalhadas de um processo Windows
     */
    ProcessInfo getWindowsProcessInfo(DWORD pid) const {
        ProcessInfo info;
        info.pid = pid;
        
        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, 
                                    FALSE, pid);
        if (!hProcess) {
            return info;
        }
        
        // Nome do processo
        wchar_t processName[MAX_PATH];
        if (GetModuleBaseNameW(hProcess, nullptr, processName, MAX_PATH)) {
            int size = WideCharToMultiByte(CP_UTF8, 0, processName, -1, 
                                         nullptr, 0, nullptr, nullptr);
            std::string name(size - 1, '\0');
            WideCharToMultiByte(CP_UTF8, 0, processName, -1, 
                              name.data(), size, nullptr, nullptr);
            info.name = name;
        }
        
        // Caminho completo
        WindowsSpecific win_data;
        wchar_t processPath[MAX_PATH];
        DWORD pathLength = MAX_PATH;
        if (QueryFullProcessImageNameW(hProcess, 0, processPath, &pathLength)) {
            int size = WideCharToMultiByte(CP_UTF8, 0, processPath, -1, 
                                         nullptr, 0, nullptr, nullptr);
            std::string path(size - 1, '\0');
            WideCharToMultiByte(CP_UTF8, 0, processPath, -1, 
                              path.data(), size, nullptr, nullptr);
            win_data.image_path = path;
            info.command_line = path;
        }
        
        // Informa√ß√µes de mem√≥ria
        PROCESS_MEMORY_COUNTERS pmc;
        if (GetProcessMemoryInfo(hProcess, &pmc, sizeof(pmc))) {
            info.resident_memory = pmc.WorkingSetSize / 1024; // KB
            info.virtual_size = pmc.PagefileUsage / 1024; // KB
        }
        
        // Session ID
        if (!ProcessIdToSessionId(pid, &win_data.session_id)) {
            win_data.session_id = 0;
        }
        
        info.platform_data = win_data;
        CloseHandle(hProcess);
        return info;
    }
    
public:
    std::vector<ProcessInfo> enumerateProcesses() override {
        std::vector<ProcessInfo> processes;
        
        HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (hSnapshot == INVALID_HANDLE_VALUE) {
            return processes;
        }
        
        PROCESSENTRY32W pe32;
        pe32.dwSize = sizeof(PROCESSENTRY32W);
        
        if (Process32FirstW(hSnapshot, &pe32)) {
            do {
                auto info = getWindowsProcessInfo(pe32.th32ProcessID);
                info.parent_pid = pe32.th32ParentProcessID;
                
                if (!info.name.empty()) {
                    processes.push_back(std::move(info));
                }
            } while (Process32NextW(hSnapshot, &pe32));
        }
        
        CloseHandle(hSnapshot);
        return processes;
    }
    
    MemoryLayout analyzeMemoryLayout(pid_t pid) override {
        MemoryLayout layout;
        
        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, 
                                    FALSE, pid);
        if (!hProcess) {
            return layout;
        }
        
        MEMORY_BASIC_INFORMATION mbi;
        uintptr_t address = 0;
        
        while (VirtualQueryEx(hProcess, reinterpret_cast<LPCVOID>(address), 
                            &mbi, sizeof(mbi)) == sizeof(mbi)) {
            if (mbi.State == MEM_COMMIT) {
                MemoryRegion region;
                region.start_address = reinterpret_cast<uintptr_t>(mbi.BaseAddress);
                region.end_address = region.start_address + mbi.RegionSize;
                region.size_kb = mbi.RegionSize / 1024;
                
                // Determina permiss√µes
                std::string perms;
                if (mbi.Protect & PAGE_EXECUTE) perms += "x";
                if (mbi.Protect & PAGE_READWRITE) perms += "rw";
                else if (mbi.Protect & PAGE_READONLY) perms += "r";
                region.permissions = perms;
                
                // Determina tipo
                if (mbi.Type == MEM_IMAGE) {
                    region.region_type = "Image";
                } else if (mbi.Type == MEM_MAPPED) {
                    region.region_type = "Mapped";
                } else {
                    region.region_type = "Private";
                }
                
                layout.regions.push_back(region);
                layout.total_virtual_memory += region.size_kb;
            }
            
            address = reinterpret_cast<uintptr_t>(mbi.BaseAddress) + mbi.RegionSize;
        }
        
        layout.vas_info = getVirtualAddressSpace();
        CloseHandle(hProcess);
        return layout;
    }
    
    VirtualAddressSpace getVirtualAddressSpace() override {
        VirtualAddressSpace vas;
        
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        
        if (sizeof(void*) == 8) { // 64-bit
            vas.user_space_start = 0x0000000000000000ULL;
            vas.user_space_end = 0x00007FFFFFFFFFFFULL;
            vas.kernel_space_start = 0xFFFF800000000000ULL;
            vas.kernel_space_end = 0xFFFFFFFFFFFFFFFFULL;
            vas.mode = AddressingMode::Bit48;
        } else { // 32-bit
            vas.user_space_start = 0x00000000;
            vas.user_space_end = 0x7FFFFFFF;
            vas.kernel_space_start = 0x80000000;
            vas.kernel_space_end = 0xFFFFFFFF;
            vas.mode = AddressingMode::Bit32;
        }
        
        vas.page_size = si.dwPageSize;
        vas.kpti_enabled = true; // Assumimos KPTI ativo em Windows modernos
        
        return vas;
    }
    
    ProcessType determineProcessType(const ProcessInfo& info) override {
        const auto* win_data = info.getWindowsData();
        if (!win_data) return ProcessType::Unknown;
        
        // Processos de sistema conhecidos
        if (info.name == "System" || info.name == "Registry" || 
            info.name == "MemCompression") {
            return ProcessType::SystemProcess;
        }
        
        if (win_data->session_id == 0) {
            return ProcessType::Service;
        }
        
        return ProcessType::User;
    }
    
    std::string getPlatformName() const override {
        return "Windows";
    }
};
#endif

/**
 * @brief N√≥ da hierarquia de processos
 */
struct ProcessNode {
    ProcessInfo info;
    std::shared_ptr<ProcessNode> parent;
    std::vector<std::shared_ptr<ProcessNode>> children;
    
    size_t getDescendantCount() const {
        size_t count = children.size();
        for (const auto& child : children) {
            count += child->getDescendantCount();
        }
        return count;
    }
};

/**
 * @brief Hierarquia completa de processos
 */
struct ProcessHierarchy {
    std::shared_ptr<ProcessNode> root;
    std::unordered_map<pid_t, std::shared_ptr<ProcessNode>> process_map;
    size_t total_processes{0};
    size_t kernel_processes{0};
    size_t user_processes{0};
    size_t system_processes{0};
};

/**
 * @brief Construtor de hierarquia de processos
 */
class HierarchyMapper {
public:
    ProcessHierarchy buildHierarchy(const std::vector<ProcessInfo>& processes,
                                  PlatformInterface& platform) {
        ProcessHierarchy hierarchy;
        hierarchy.total_processes = processes.size();
        
        // Cria n√≥s para todos os processos
        for (const auto& proc : processes) {
            auto node = std::make_shared<ProcessNode>();
            node->info = proc;
            node->info.type = platform.determineProcessType(proc);
            
            hierarchy.process_map[proc.pid] = node;
            
            // Contabiliza tipos
            switch (node->info.type) {
                case ProcessType::KernelThread:
                    hierarchy.kernel_processes++;
                    break;
                case ProcessType::SystemProcess:
                case ProcessType::Service:
                    hierarchy.system_processes++;
                    break;
                case ProcessType::User:
                    hierarchy.user_processes++;
                    break;
                default:
                    break;
            }
        }
        
        // Constr√≥i a √°rvore
        std::shared_ptr<ProcessNode> root_candidate;
        for (auto& [pid, node] : hierarchy.process_map) {
            if (node->info.parent_pid == 0 || 
                hierarchy.process_map.find(node->info.parent_pid) == hierarchy.process_map.end()) {
                // Este √© um processo raiz
                if (!root_candidate || pid < root_candidate->info.pid) {
                    root_candidate = node;
                }
            } else {
                // Conecta ao pai
                auto parent = hierarchy.process_map[node->info.parent_pid];
                node->parent = parent;
                parent->children.push_back(node);
            }
        }
        
        hierarchy.root = root_candidate;
        return hierarchy;
    }
};

/**
 * @brief Visualizador ASCII para demonstra√ß√µes educativas
 */
class ASCIIVisualizer {
public:
    std::string createProcessTreeVisualization(const ProcessHierarchy& hierarchy) {
        if (!hierarchy.root) return "Nenhuma hierarquia dispon√≠vel\n";
        
        std::ostringstream oss;
        oss << "=== √Årvore de Processos ===\n\n";
        
        generateTreeVisualization(hierarchy.root, oss, "", true);
        
        oss << std::format("\nEstat√≠sticas:\n");
        oss << std::format("‚îú‚îÄ‚îÄ Total de processos: {}\n", hierarchy.total_processes);
        oss << std::format("‚îú‚îÄ‚îÄ Processos de usu√°rio: {}\n", hierarchy.user_processes);
        oss << std::format("‚îú‚îÄ‚îÄ Processos de sistema: {}\n", hierarchy.system_processes);
        oss << std::format("‚îî‚îÄ‚îÄ Threads do kernel: {}\n", hierarchy.kernel_processes);
        
        return oss.str();
    }
    
    std::string createMemoryLayoutDiagram(const MemoryLayout& layout) {
        std::ostringstream oss;
        oss << "=== Layout de Mem√≥ria Virtual ===\n\n";
        
        const auto& vas = layout.vas_info;
        oss << std::format("Modo de endere√ßamento: {}\n", 
                          vas.mode == AddressingMode::Bit48 ? "48-bit" : 
                          vas.mode == AddressingMode::Bit64 ? "64-bit" : "32-bit");
        oss << std::format("KASLR: {} | KPTI: {}\n", 
                          vas.kaslr_enabled ? "ATIVO" : "INATIVO",
                          vas.kpti_enabled ? "ATIVO" : "INATIVO");
        oss << std::format("Tamanho da p√°gina: {} bytes\n\n", vas.page_size);
        
        oss << "Espa√ßos de endere√ßamento:\n";
        oss << std::format("‚îú‚îÄ‚îÄ User Space:   0x{:016X} - 0x{:016X}\n", 
                          vas.user_space_start, vas.user_space_end);
        oss << std::format("‚îî‚îÄ‚îÄ `kernel` Space: 0x{:016X} - 0x{:016X}\n\n", 
                          vas.kernel_space_start, vas.kernel_space_end);
        
        oss << "Regi√µes de mem√≥ria mapeadas:\n";
        for (const auto& region : layout.regions | std::views::take(10)) {
            oss << std::format("‚îú‚îÄ‚îÄ [0x{:012X}-0x{:012X}] {:4} {:12} {:8} KB\n",
                              region.start_address, region.end_address,
                              region.permissions, region.region_type, region.size_kb);
        }
        
        if (layout.regions.size() > 10) {
            oss << std::format("‚îî‚îÄ‚îÄ ... e mais {} regi√µes\n", layout.regions.size() - 10);
        }
        
        oss << std::format("\n Uso de mem√≥ria:\n");
        oss << std::format("‚îú‚îÄ‚îÄ Virtual total: {:.2f} MB\n", layout.total_virtual_memory / 1024.0);
        oss << std::format("‚îî‚îÄ‚îÄ Residente: {:.2f} MB\n", layout.total_resident_memory / 1024.0);
        
        return oss.str();
    }
    
private:
    void generateTreeVisualization(std::shared_ptr<ProcessNode> node, 
                                 std::ostringstream& oss,
                                 const std::string& prefix, 
                                 bool is_last) {
        if (!node) return;
        
        // S√≠mbolos da √°rvore
        std::string connector = is_last ? "‚îî‚îÄ‚îÄ " : "‚îú‚îÄ‚îÄ ";
        std::string type_symbol = getProcessTypeSymbol(node->info.type);
        
        oss << prefix << connector << type_symbol 
            << std::format("{} (PID: {}, Children: {})\n", 
                          node->info.name, node->info.pid, node->children.size());
        
        // Prefixo para os filhos
        std::string child_prefix = prefix + (is_last ? "    " : "‚îÇ   ");
        
        // Processa filhos
        for (size_t i = 0; i < node->children.size(); ++i) {
            bool child_is_last = (i == node->children.size() - 1);
            generateTreeVisualization(node->children[i], oss, child_prefix, child_is_last);
        }
    }
    
    std::string getProcessTypeSymbol(ProcessType type) {
        switch (type) {
            case ProcessType::KernelThread: return " ";
            case ProcessType::SystemProcess: return " ";
            case ProcessType::Service: return " ";
            case ProcessType::User: return " ";
            default: return " ";
        }
    }
};

/**
 * @brief Simulador TLB integrado (da implementa√ß√£o anterior)
 */
class TLBSimulator {
private:
    size_t tlb_size_;
    std::unordered_map<uint64_t, bool> tlb_cache_;
    struct {
        double tlb_hit_time;
        double page_table_access_time;
        size_t total_accesses;
        size_t tlb_hits;
        size_t tlb_misses;
    } metrics_;
    
public:
    TLBSimulator(size_t tlb_size, double hit_time, double pt_time) 
        : tlb_size_(tlb_size) {
        metrics_.tlb_hit_time = hit_time;
        metrics_.page_table_access_time = pt_time;
        metrics_.total_accesses = 0;
        metrics_.tlb_hits = 0;
        metrics_.tlb_misses = 0;
    }
    
    bool accessMemory(uint64_t virtual_address) {
        uint64_t page_number = virtual_address >> 12;
        metrics_.total_accesses++;
        
        if (tlb_cache_.contains(page_number)) {
            metrics_.tlb_hits++;
            return true;
        } else {
            metrics_.tlb_misses++;
            if (tlb_cache_.size() >= tlb_size_) {
                tlb_cache_.erase(tlb_cache_.begin());
            }
            tlb_cache_[page_number] = true;
            return false;
        }
    }
    
    auto getMetrics() const { return metrics_; }
    double getEffectiveAccessTime() const {
        double miss_rate = static_cast<double>(metrics_.tlb_misses) / metrics_.total_accesses;
        return metrics_.tlb_hit_time + (miss_rate * metrics_.page_table_access_time);
    }
};

/**
 * @brief Monitor principal do sistema
 */
class SystemProcessMonitor {
private:
    Platform platform_;
    std::unique_ptr<PlatformInterface> platform_impl_;
    std::unique_ptr<TLBSimulator> tlb_simulator_;
    
    Platform detectPlatform() {
        #ifdef _WIN32
            return Platform::Windows;
        #elif defined(__linux__)
            return Platform::Linux;
        #else
            return Platform::Unknown;
        #endif
    }
    
public:
    SystemProcessMonitor() : platform_(detectPlatform()) {
        switch (platform_) {
            case Platform::Linux:
                platform_impl_ = std::make_unique<LinuxPlatform>();
                break;
            #ifdef _WIN32
            case Platform::Windows:
                platform_impl_ = std::make_unique<WindowsPlatform>();
                break;
            #endif
            default:
                throw std::runtime_error("Plataforma n√£o suportada");
        }
        
        // Inicializa TLB simulator com configura√ß√£o padr√£o
        tlb_simulator_ = std::make_unique<TLBSimulator>(64, 1.0, 100.0);
    }
    
    void runAnalysis() {
        std::cout << "=== Monitor de Hierarquia + Memory Analysis ===\n";
        std::cout << std::format("Plataforma: {}\n\n", platform_impl_->getPlatformName());
        
        // Enumera processos
        std::cout << "Enumerando processos...\n";
        auto processes = platform_impl_->enumerateProcesses();
        std::cout << std::format("Encontrados {} processos\n\n", processes.size());
        
        // Constr√≥i hierarquia
        std::cout << "Construindo hierarquia...\n";
        HierarchyMapper mapper;
        auto hierarchy = mapper.buildHierarchy(processes, *platform_impl_);
        
        // Visualiza hierarquia
        ASCIIVisualizer visualizer;
        std::cout << visualizer.createProcessTreeVisualization(hierarchy);
        
        // An√°lise de mem√≥ria de um processo exemplo
        MemoryLayout memory_layout;
        if (!processes.empty()) {
            pid_t example_pid = processes[0].pid;
            std::cout << std::format("\nAnalisando mem√≥ria do processo {} (PID: {})...\n", 
                                   processes[0].name, example_pid);
            
            memory_layout = platform_impl_->analyzeMemoryLayout(example_pid);
            std::cout << visualizer.createMemoryLayoutDiagram(memory_layout);
            
            // Integra√ß√£o TLB Simulation
            runTLBSimulation(memory_layout);
        }
        
        // Demonstra√ß√µes educacionais espec√≠ficas da plataforma
        runEducationalDemos(hierarchy, memory_layout);
    }
    
private:
    void runTLBSimulation(const MemoryLayout& layout) {
        std::cout << "\n=== Simula√ß√£o TLB ===\n";
        
        if (!tlb_simulator_) {
            tlb_simulator_ = std::make_unique<TLBSimulator>(64, 1.0, 100.0);
        }
        
        // Gera padr√£o de acesso baseado no layout real
        std::vector<uint64_t> addresses;
        for (const auto& region : layout.regions | std::views::take(5)) {
            // Simula acessos sequenciais na regi√£o
            for (size_t i = 0; i < 100; ++i) {
                uint64_t addr = region.start_address + (i * 4096);
                if (addr < region.end_address) {
                    addresses.push_back(addr);
                }
            }
        }
        
        // Executa simula√ß√£o
        for (auto addr : addresses) {
            tlb_simulator_->accessMemory(addr);
        }
        
        auto metrics = tlb_simulator_->getMetrics();
        std::cout << std::format("TLB Hits: {} | Misses: {} | Hit Rate: {:.1f}%\n",
                                metrics.tlb_hits, metrics.tlb_misses,
                                (static_cast<double>(metrics.tlb_hits) / metrics.total_accesses) * 100);
        std::cout << std::format("Tempo efetivo de acesso: {:.2f} ciclos\n", 
                                tlb_simulator_->getEffectiveAccessTime());
    }
    
    void runEducationalDemos(const ProcessHierarchy& hierarchy, const MemoryLayout& layout) {
        std::cout << "\nüéì === Demonstra√ß√µes Educacionais ===\n";
        
        KernelConceptDemo demo;
        auto vas = platform_impl_->getVirtualAddressSpace();
        
        // Demonstra√ß√£o b√°sica independente de plataforma
        demo.demonstrateAddressSpaceSplit(vas);
        demo.showKernelVsUserProcesses(hierarchy);
        demo.explainMMUTranslation(layout);
        
        // Demonstra√ß√µes espec√≠ficas da plataforma
        if (platform_ == Platform::Linux) {
            demo.showKASLR();
            if (vas.kpti_enabled) {
                demo.visualizeKPTI();
            }
        } else if (platform_ == Platform::Windows) {
            demo.visualizeKPTI(); // Windows sempre tem KPTI
        }
        
        // Se houver dados de m√∫ltiplas plataformas, fazer an√°lise comparativa
        // (Isso seria expandido em implementa√ß√£o futura com dados persistidos)
    }
    
    void demonstratePlatformConcepts() {
        auto vas = platform_impl_->getVirtualAddressSpace();
        
        if (platform_ == Platform::Linux) {
            std::cout << "\nConceitos **Linux** espec√≠ficos detectados:\n";
            std::cout << "‚îú‚îÄ‚îÄ `kernel` threads como processos independentes\n";
            std::cout << "‚îú‚îÄ‚îÄ Sistema de arquivos /proc para introspec√ß√£o\n";
            std::cout << "‚îú‚îÄ‚îÄ vDSO para system calls otimizadas\n";
            std::cout << std::format("‚îú‚îÄ‚îÄ KASLR: {}\n", 
                                   vas.kaslr_enabled ? "ATIVO" : "INATIVO");
            std::cout << std::format("‚îî‚îÄ‚îÄ KPTI: {}\n", 
                                   vas.kpti_enabled ? "ATIVO" : "INATIVO");
        } else if (platform_ == Platform::Windows) {
            std::cout << "\nConceitos Windows espec√≠ficos detectados:\n";
            std::cout << "‚îú‚îÄ‚îÄ Separa√ß√£o por sess√µes (Session 0 = services)\n";
            std::cout << "‚îú‚îÄ‚îÄ Processos System/Registry em `kernel` space\n";
            std::cout << "‚îú‚îÄ‚îÄ Threads como unidade de escalonamento\n";
            std::cout << std::format("‚îú‚îÄ‚îÄ VAS: User (0x0-0x{:X})\n", vas.user_space_end);
            std::cout << std::format("‚îî‚îÄ‚îÄ KPTI: {}\n", 
                                   vas.kpti_enabled ? "ATIVO" : "INATIVO");
        }
    }
    
private:
/**
 * @brief Demonstra√ß√µes educacionais de conceitos de kernel
 */
class KernelConceptDemo {
public:
    struct Demo {
        std::string concept_name;
        std::string description;
        std::function<void()> demonstration;
        std::vector<std::string> educational_notes;
    };
    
    void demonstrateAddressSpaceSplit(const VirtualAddressSpace& vas) {
        std::cout << "\nüéì === Demonstra√ß√£o: Divis√£o do Espa√ßo de Endere√ßamento ===\n";
        std::cout << "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n";
        std::cout << "‚îÇ                ESPA√áO DE ENDERE√áAMENTO VIRTUAL          ‚îÇ\n";
        std::cout << "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n";
        std::cout << std::format("‚îÇ `kernel` Space: 0x{:016X} - 0x{:016X} ‚îÇ\n", 
                                vas.kernel_space_start, vas.kernel_space_end);
        std::cout << "‚îÇ                    [PROTEGIDO]                          ‚îÇ\n";
        std::cout << "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n";
        std::cout << "‚îÇ                     [BURACO]                            ‚îÇ\n";
        std::cout << "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n";
        std::cout << std::format("‚îÇ User Space:   0x{:016X} - 0x{:016X} ‚îÇ\n", 
                                vas.user_space_start, vas.user_space_end);
        std::cout << "‚îÇ                   [ACESS√çVEL]                           ‚îÇ\n";
        std::cout << "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n";
        
        std::cout << "\nConceitos importantes:\n";
        std::cout << "‚Ä¢ MMU impede acesso de user-space ao kernel-space\n";
        std::cout << "‚Ä¢ transi√ß√µes user‚Üíkernel via system calls ou interrup√ß√µes\n";
        std::cout << std::format("‚Ä¢ KPTI: {} (prote√ß√£o adicional)\n", 
                                vas.kpti_enabled ? "ATIVO" : "INATIVO");
    }
    
    void showKernelVsUserProcesses(const ProcessHierarchy& hierarchy) {
        std::cout << "\nüéì === Demonstra√ß√£o: Processos `kernel` vs User ===\n";
        
        size_t kernel_count = 0, user_count = 0, system_count = 0;
        for (const auto& [pid, node] : hierarchy.process_map) {
            switch (node->info.type) {
                case ProcessType::KernelThread: kernel_count++; break;
                case ProcessType::User: user_count++; break;
                case ProcessType::SystemProcess: 
                case ProcessType::Service: system_count++; break;
                default: break;
            }
        }
        
        std::cout << "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n";
        std::cout << "‚îÇ Tipo            ‚îÇ Quantidade‚îÇ Caracter√≠sticas         ‚îÇ\n";
        std::cout << "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n";
        std::cout << std::format("‚îÇ `kernel`       ‚îÇ {:9} ‚îÇ Ring 0, sem user space  ‚îÇ\n", kernel_count);
        std::cout << std::format("‚îÇ System       ‚îÇ {:9} ‚îÇ Privil√©gios elevados    ‚îÇ\n", system_count);
        std::cout << std::format("‚îÇ User         ‚îÇ {:9} ‚îÇ Ring 3, isolados       ‚îÇ\n", user_count);
        std::cout << "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n";
    }
    
    void explainMMUTranslation(const MemoryLayout& layout) {
        std::cout << "\nüéì === Demonstra√ß√£o: tradu√ß√£o MMU ===\n";
        std::cout << "Exemplo de tradu√ß√£o de endere√ßo virtual para f√≠sico:\n\n";
        
        if (!layout.regions.empty()) {
            const auto& region = layout.regions[0];
            uint64_t virtual_addr = region.start_address;
            
            std::cout << std::format("Endere√ßo Virtual: 0x{:016X}\n", virtual_addr);
            std::cout << "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n";
            std::cout << "‚îÇ Bits 47-39 ‚îÇ Bits 38-30 ‚îÇ Bits 29-21 ‚îÇ Bits 20-12 ‚îÇ\n";
            std::cout << "‚îÇ   PML4E     ‚îÇ   PDPTE     ‚îÇ    PDE     ‚îÇ    PTE     ‚îÇ\n";
            std::cout << "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n";
            std::cout << std::format("‚îÇ    {:3}      ‚îÇ    {:3}      ‚îÇ    {:3}      ‚îÇ    {:3}      ‚îÇ\n",
                                    (virtual_addr >> 39) & 0x1FF,
                                    (virtual_addr >> 30) & 0x1FF,
                                    (virtual_addr >> 21) & 0x1FF,
                                    (virtual_addr >> 12) & 0x1FF);
            std::cout << "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n";
            std::cout << std::format("                     Offset: 0x{:03X} (Bits 11-0)\n", 
                                    virtual_addr & 0xFFF);
        }
    }
    
    void visualizeKPTI() {
        std::cout << "\nüéì === Demonstra√ß√£o: KPTI (Kernel Page Table Isolation) ===\n";
        std::cout << "Prote√ß√£o contra Meltdown:\n\n";
        
        std::cout << "SEM KPTI (Vulner√°vel):\n";
        std::cout << "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n";
        std::cout << "‚îÇ        Tabela de P√°ginas √∫nica      ‚îÇ\n";
        std::cout << "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n";
        std::cout << "‚îÇ User mappings    [VIS√çVEL]          ‚îÇ\n";
        std::cout << "‚îÇ `kernel` mappings  [VIS√çVEL]         ‚îÇ\n";
        std::cout << "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n";
        
        std::cout << "COM KPTI (Protegido):\n";
        std::cout << "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n";
        std::cout << "‚îÇ User Page Table ‚îÇ  ‚îÇKernel Page Table‚îÇ\n";
        std::cout << "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n";
        std::cout << "‚îÇ User mappings   ‚îÇ  ‚îÇ User mappings   ‚îÇ\n";
        std::cout << "‚îÇ `kernel` stub ‚úì   ‚îÇ  ‚îÇ `kernel` full ‚úì   ‚îÇ\n";
        std::cout << "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n";
        std::cout << "      User Mode           `kernel` Mode\n";
    }
    
    void showKASLR() {
        std::cout << "\nüéì === Demonstra√ß√£o: KASLR (Kernel Address Space Layout Randomization) ===\n";
        std::cout << "Randomiza√ß√£o do layout do kernel:\n\n";
        
        std::cout << "SEM KASLR (Previs√≠vel):\n";
        std::cout << "Kernel sempre em: 0xFFFFFFFF80000000\n";
        std::cout << "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n";
        std::cout << "‚îÇ 0xFFFFFFFF80000000: kernel_start    ‚îÇ\n";
        std::cout << "‚îÇ 0xFFFFFFFF80001000: importante_func ‚îÇ\n";
        std::cout << "‚îÇ 0xFFFFFFFF80002000: syscall_table   ‚îÇ\n";
        std::cout << "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n";
        
        std::cout << "COM KASLR (Randomizado):\n";
        std::cout << "Base aleat√≥ria: 0xFFFFFFFF80000000 + RANDOM_OFFSET\n";
        std::cout << "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n";
        std::cout << "‚îÇ 0xFFFFFFFF85A32000: kernel_start    ‚îÇ\n";
        std::cout << "‚îÇ 0xFFFFFFFF85A33000: importante_func ‚îÇ\n";
        std::cout << "‚îÇ 0xFFFFFFFF85A34000: syscall_table   ‚îÇ\n";
        std::cout << "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n";
        std::cout << "Dificulta exploits que dependem de endere√ßos fixos\n";
    }
};

/**
 * @brief Analisador comparativo entre plataformas
 */
class ComparativeAnalyzer {
public:
    struct Metric {
        std::string name;
        std::variant<double, size_t, std::string> linux_value;
        std::variant<double, size_t, std::string> windows_value;
        std::string interpretation;
    };
    
    struct PlatformComparison {
        std::vector<Metric> metrics;
        std::string summary;
    };
    
    PlatformComparison compareProcessModels(const ProcessHierarchy& linux_hier,
                                           const ProcessHierarchy& windows_hier) {
        PlatformComparison comparison;
        
        comparison.metrics.push_back({
            "Total de Processos",
            linux_hier.total_processes,
            windows_hier.total_processes,
            "Windows tipicamente tem mais processos devido √† arquitetura de servi√ßos"
        });
        
        comparison.metrics.push_back({
            "Kernel Threads",
            linux_hier.kernel_processes,
            static_cast<size_t>(0), // Windows n√£o exp√µe `kernel` threads como processos
            "Linux exp√µe `kernel` threads como processos independentes [kworker], [ksoftirqd]"
        });
        
        comparison.metrics.push_back({
            "Processos de Sistema",
            linux_hier.system_processes,
            windows_hier.system_processes,
            "Windows centraliza em poucos processos (System, Registry), **Linux** distribui mais"
        });
        
        comparison.summary = "Linux: Modelo UNIX tradicional com hierarquia clara a partir do init/systemd.\n"
                           "Windows: Modelo orientado a objetos com separa√ß√£o por sess√µes e servi√ßos.";
        
        return comparison;
    }
    
    void displayComparison(const PlatformComparison& comparison) {
        std::cout << "\n=== An√°lise Comparativa: **Linux** vs Windows ===\n";
        std::cout << "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n";
        std::cout << "‚îÇ M√©trica              ‚îÇ **Linux**       ‚îÇ Windows     ‚îÇ\n";
        std::cout << "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n";
        
        for (const auto& metric : comparison.metrics) {
            std::cout << std::format("‚îÇ {:20} ‚îÇ ", metric.name.substr(0, 20));
            
            // **Linux** value
            std::visit([](const auto& value) {
                std::cout << std::format("{:11} ‚îÇ ", value);
            }, metric.linux_value);
            
            // Windows value  
            std::visit([](const auto& value) {
                std::cout << std::format("{:11} ‚îÇ\n", value);
            }, metric.windows_value);
            
            if (!metric.interpretation.empty()) {
                std::cout << std::format("‚îÇ ‚îî‚îÄ {}\n", 
                                       metric.interpretation.substr(0, 50) + 
                                       (metric.interpretation.length() > 50 ? "..." : ""));
            }
        }
        
        std::cout << "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n";
        std::cout << "\nResumo:\n" << comparison.summary << "\n";
    }
};
};

/**
 * @brief Fun√ß√£o principal
 */
int main() {
    try {
        SystemProcessMonitor monitor;
        
        std::cout << "=== Monitor de Hierarquia + Memory Analysis ===\n";
        std::cout << "Escolha o modo de opera√ß√£o:\n";
        std::cout << "1. An√°lise r√°pida autom√°tica\n";
        std::cout << "2. Modo interativo educacional\n";
        std::cout << "Op√ß√£o: ";
        
        int choice;
        std::cin >> choice;
        
        if (choice == 2) {
            EducationalCLI cli(monitor);
            cli.runInteractiveMode();
        } else {
            monitor.runAnalysis();
        }
        
        std::cout << "\nAn√°lise conclu√≠da com sucesso!\n";
        std::cout << "Este programa demonstra diferen√ßas fundamentais entre\n";
        std::cout << "   arquiteturas de processo **Linux** e Windows.\n";
        
    } catch (const std::exception& e) {
        std::cerr << "Erro: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
```
