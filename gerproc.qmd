# Gerenciamento de Processos: Introdução {#sec-gerproc}

::: {.content-hidden when-format="pdf"}
:::{.callout-tip}
Está sem tempo? Leia o [Expresso](.\ex\gerproc-expresso.html).
:::
:::


Como a atenta leitora deve lembrar, os **Sistemas Operacionais** evoluíram de módulos de controle para gerenciar programas a fim de otimizar o uso das `CPU`s que eram muito, muito, muito caras. Ao longo de mais de $70$ anos de desenvolvimento de **Sistemas Operacionais** as técnicas de execução de programas em sistemas computacionais mudaram muito. Hoje, na terceira década do século XXI, **o gerenciamento eficaz de processos requer coordenação sofisticada da organização de memória, algoritmos de escalonamento, comunicação entre processos e mecanismos de sincronização**. Ainda assim, o gerenciamento  tradicional de processos e `threads` representa apenas uma das dimensões da execução concorrente em sistemas computacionais modernos. As aplicações contemporâneas dependem de abstrações sofisticadas de execução que oferecem abordagens fundamentalmente diferentes para gerenciar concorrência, paralelismo e utilização de recursos. Essas abstrações, incluindo `coroutines`, `green threads`, `fibers`, o `actor model` e arquiteturas orientadas a eventos, emergiram de décadas de pesquisa acadêmica e representam inovações críticas em como projetamos e implementamos **Sistemas Operacionais**.

Começando com processos e `threads`, vamos explorar os fundamentos do gerenciamento de processos, desde a criação até a finalização, passando por conceitos essenciais como espaço de endereçamento virtual, tabelas de páginas e o ciclo de vida de um processo. Em seguida, vamos analisar as abstrações modernas de execução concorrente, como `coroutines`, `green threads`, `fibers`, o `actor model` e arquiteturas orientadas a eventos, destacando suas vantagens e desvantagens em relação ao modelo  tradicional de processos e `threads`.

A afoita leitora, se segure, a jornada será longa e trabalhosa. Começamos com processos e `threads` em **Sistemas Operacionais** Modernos.

## Fundamentos da arquitetura de processos e threads

Vamos começar com os conceitos fundamentais de processos e `threads`, que são essenciais para entender como os **Sistemas Operacionais** modernos gerenciam a execução de programas. Esses conceitos formam a base sobre a qual as abstrações mais avançadas de concorrência serão construídas.

### Processos {#sec-processos1}

_Os processos, as vezes chamados de tarefas,  `tasks`, são unidades fundamentais de execução em **Sistemas Operacionais**, definidos como instâncias de programas em execução ativa com alocações dedicadas de recursos_.

Se o arquivo executável é a planta de uma casa, o processo é a casa sendo construída, habitada e mantida. Um processo é muito mais que apenas código em memória; é um ecossistema dinâmico que possui seu próprio espaço de endereçamento, recursos alocados, como arquivos abertos e conexões de rede, e um estado de execução gerenciado pelo `kernel`. Para tanto, cada processo opera em um espaço de memória isolado, que chamaremos de `espaço de endereçamento`, organizado em quatro segmentos principais:

- **Segmento de texto**: contém o código executável do programa.
- **Segmento de dados**: armazena variáveis globais e estáticas.
- **Heap**: utilizado para alocação dinâmica de memória durante a execução.
- **Stack**: gerencia chamadas de função e variáveis locais.

Esse layout de memória garante segurança por meio do isolamento entre processos e eficiência por meio de uma organização estruturada. Nós adotaremos esta estrutura como padrão. Entretanto, a esperta leitora não deve se deixar enganar. nem todos os processos em todos os **Sistemas Operacionais** possuem exatamente a estrutura descrita como padrão, embora o modelo seja amplamente adotado em **Sistemas Operacionais** modernos, como os baseados em UNIX (Linux, macOS) e Windows. A estrutura de um processo pode variar dependendo do **Sistema Operacional**, da arquitetura de hardware e do design específico do sistema. Antes de prosseguirmos, abaixo estão alguns pontos que devem ser considerados sobre estas variações:

1. **Segmentos de Memória**: a divisão em segmentos de texto, dados, ``heap`` e `stack` é comum em **Sistemas Operacionais** que utilizam um modelo de memória virtual, tais como **Linux** e Windows. No entanto, **Sistemas Operacionais** mais simples ou embarcados podem usar modelos mais rudimentares, como uma única região de memória para código e dados, sem separação clara.

2. **Sistemas Operacionais Especiais**: em **Sistemas Operacionais** de tempo real, **RTOS** como o [QNX](https://blackberry.qnx.com/en),  sistemas embarcados, como [FreeRTOS](https://www.freertos.org/) ou [VxWorks](https://www.windriver.com/products/vxworks), a estrutura de processos pode ser mais simplificada, com menos camadas de abstração, devido a restrições de recursos ou requisitos de desempenho.

3. **Gerenciamento de Memória**: em alguns **Sistemas Operacionais** legados ou minimalistas, como o MS-DOS, não há suporte robusto para isolamento de memória ou segmentação, o que resulta em processos com estruturas mais rudimentares, sem separação clara entre código, dados e pilha.

4. **Arquiteturas de Hardware**: a estrutura de um processo também depende da arquitetura subjacente. Por exemplo, em arquiteturas como **ARM** ou **RISC-V**, a organização de memória pode ser adaptada para otimizar o desempenho em hardware específico.

5. **Sistemas Operacionais Experimentais**: alguns **Sistemas Operacionais** experimentais ou acadêmicos podem adotar modelos de processos completamente diferentes, como microkernels, como o [MINIX](https://www.minix3.org/), no qual processos são mais leves e serviços do sistema são executados como processos de usuário,  sistemas monolíticos com estruturas de memória personalizadas.

::: callout-note
**Sistemas Operacionais Experimentais**
Alguns **Sistemas Operacionais** experimentais e acadêmicos adotam modelos de processos que diferem significativamente do modelo  tradicional. Aqui estão alguns exemplos notáveis:

- **Singularity**: um **Sistema Operacional** experimental desenvolvido pela [Microsoft Research](https://www.microsoft.com/en-us/research/). O Singularity usa um modelo monolítico, mas com uma abordagem única chamada **S**oftware-**I**solated **P**rocesses, **SIP**s. Em vez de confiar em isolamento de memória baseado em hardware, como em sistemas tradicionais, o Singularity utiliza verificação de tipo em tempo de compilação e um modelo de memória personalizado para garantir isolamento entre processos. Isso elimina a necessidade de segmentação  tradicional em alguns casos, já que os processos compartilham um espaço de endereçamento seguro definido pelo sistema.

- **Barrelfish**: um **Sistema Operacional** acadêmico projetado para arquiteturas multicore e heterogêneas. O [Barrelfish](https://barrelfish.org/) adota um modelo híbrido, mas com uma estrutura de memória altamente personalizada para seus processos, chamada `multikernel`. Nesse modelo, cada núcleo do processador pode gerenciar processos de maneira independente, com estruturas de memória adaptadas ao hardware subjacente, em vez de seguir o layout clássico de segmentos de memória.

- **L4**: uma família de `microkernels` que enfatiza processos extremamente leves e isolamento rigoroso. No **seL4**, um dos sistemas desta família, os processos,  `threads`, em alguns contextos, têm uma estrutura minimalista, com gerenciamento de memória projetado para segurança formalmente verificada, em vez de seguir a organização  tradicional de processos.

- **Plan 9**: Desenvolvido pela Bell Labs, o [Plan 9](https://p9f.org/) é um **Sistema Operacional** experimental que adota um modelo monolítico, mas com uma abordagem única para processos e memória. Ele utiliza um espaço de nomes por processo, no inglês per-process namespace, permitindo que cada processo tenha uma visão personalizada do sistema de arquivos e outros recursos, o que altera a forma como a memória é estruturada e acessada.
:::

::: {#fig-espacoend1}
![](/images/memory_process_comparison.webp)

Comparação entre estruturas de processos em memória: espaço de endereçamento. À esquerda, layout típico de um **Sistema Operacional** moderno (Linux/UNIX) em arquitetura 64-bit, mostrando segmentação clara com stack crescendo a partir de endereços altos, `heap` com alocação dinâmica, e segmentos de dados e código em posições fixas. À direita, estrutura simplificada de sistema embarcado (FreeRTOS) em microcontrolador 32-bit, apresentando layout determinado pelo hardware com memory-mapped `E/S`, SRAM unificada para dados e stacks de tarefas, e flash separada para código. As setas indicam direções de crescimento da memória, e as áreas tracejadas representam espaços não mapeados ou livres para expansão. Note-se a ausência de MMU no sistema embarcado, resultando em acesso direto à memória física, contrastando com o modelo de memória virtual do sistema moderno.
:::

A @fig-espacoend1 mostra a estrutura de memória tradicional e mais comum com a estrutura do **RTOS**. O processo de gestão de projetos não é trivial. O **Sistema Operacional** é o principal ator na gestão de processos, sendo responsável por:

1. **Criação e exclusão**: gerencia processos de usuário, processos iniciados exclusivamente por usuários, e processos de sistema, iniciados pelo próprio **Sistema Operacional**.
2. **Suspensão e retomada**: controla a pausa e retomada de processos, preservando seu estado, incluindo registradores, contador de programa e pilha.
3. **Sincronização de processos**: coordena o acesso a recursos compartilhados para evitar condições de corrida e garantir consistência de dados.
4. **Comunicação entre processos**: facilita a troca de informações por meio de mecanismos como pipes, sockets, memória compartilhada, mensagens ou sinais. Em inglês, a comunicação entre processos é chamada de **I**nter **P**rocess **C**ommunication, **IPC**.
5. **Tratamento de deadlocks**: detecta e resolve situações em que processos ficam permanentemente bloqueados, assegurando a continuidade da operação do sistema.

#### Processos: muito além do executável

Processo é um executável em memória usando tempo de processamento da `CPU`, mas é muito mais do que isso. É uma entidade dinâmica que encapsula a execução de um programa, incluindo seu estado, recursos alocados e contexto de execução. E aqui há um problema de semântica. Quando pensamos em executáveis esquecemos os drivers, as bibliotecas de ligação dinâmica, os processos de sistema e outros componentes que são executados pelo **Sistema Operacional**. No coração de cada programa e aplicativo que utilizamos, existe um arquivo executável, um conjunto de instruções que o **Sistema Operacional** pode entender e executar. No entanto, o formato desses arquivos varia consideravelmente entre os diferentes **Sistemas Operacionais**, cada um com sua própria arquitetura e filosofia de design e com a finalidade do arquivo executável. Compreender esses tipos de executáveis é fundamental para entender como o software funciona em plataformas modernas como Windows, macOS, **Linux** e Android.

Cada **Sistema Operacional** possui um formato primário de arquivo executável, além de outros tipos que servem a propósitos específicos.

1. **Windows**: o formato mais onipresente no universo **Windows** é o `.exe`, em inglês _executable_. Este arquivo no formato **P**ortable **E**xecutable, **PE** contém o código do programa, dados, e recursos necessários para a sua execução. Além do `.exe`, tros formatos executáveis comuns incluem:

   - `.msi` (Microsoft Installer): Usado para a instalação, manutenção e remoção de software;
   - `.bat` (Batch): Scripts de texto simples contendo uma série de comandos a serem executados pelo interpretador de comandos do Windows;
   - `.com` (Command): Um tipo mais simples e antigo de executável, geralmente menor que um `.exe`;
   - `.dll` (Dynamic Link Library): Embora não sejam executáveis diretamente pelo usuário, são bibliotecas de código que os arquivos `.exe` podem carregar e executar em tempo de execução;
   - `.scr` (Screen Saver): Arquivos de proteção de tela, que são essencialmente programas `.exe` com uma extensão diferente.

2. **No macOS**: o sistema da Apple utiliza uma abordagem diferente. As aplicações são geralmente distribuídas como pacotes `.app`.trata-se de um diretório que encapsula todos os arquivos necessários para a aplicação funcionar, incluindo o executável principal, recursos, bibliotecas e metadados. O formato do executável binário subjacente no macOS é o **Mach-O (Mach Object)**. Arquivos Mach-O, muitas vezes não possuem extensão, e sua natureza executável é definida pelas permissões do sistema de arquivos, de forma similar ao Linux.

   - `.app` (Application Bundle): O formato de distribuição padrão para aplicações macOS.
   - `.dmg` (Disk Image): Embora não seja um executável por si só, é um formato de contêiner comum para distribuir aplicações `.app`.
   - Scripts de Shell: Assim como no **Linux**, scripts com extensões como `.sh` ou sem extensão podem ser tornados executáveis.

3. **No Linux**: no **Linux**, a base para quase todo código compilado é o formato **E**xecutable and **L**inkable **F**ormat, **ELF**. No entanto, assim como no Windows, existem diferentes tipos de arquivos e componentes que utilizam este formato para propósitos distintos. A executabilidade é primariamente definida por permissões de arquivo, e não pela extensão.

   - `so` (Shared Object): Embora não sejam executáveis diretamente pelo usuário, são bibliotecas de código no formato ELF que múltiplos programas podem carregar e usar em tempo de execução para compartilhar funcionalidades comuns, de forma análoga aos arquivos `.dll` do Windows.
   - `.ko` (Kernel Object): Arquivos de driver,  módulos do `kernel`. São arquivos especiais em formato ELF que são carregados diretamente no núcleo (kernel) do **Sistema Operacional** para permitir a comunicação com o hardware. Não são executáveis no espaço do usuário.
   - **Scripts**: Arquivos de texto (ex: `.sh`, `.py`) que se tornam executáveis através de permissões e da especificação de um interpretador (ex: `#!/bin/bash`). O **Sistema Operacional** executa o interpretador, que por sua vez lê e executa os comandos do script.

4. **No Android**: o **Sistema Operacional** móvel do Google, baseado no `kernel` **Linux**, tem seus próprios formatos de executáveis específicos para aplicações.

   - `.apk` (Android Package Kit): O formato de arquivo usado para distribuir e instalar aplicativos móveis. Um arquivo `.apk` contém o código do programa (em formato DEX), recursos, assets e o manifesto do aplicativo.
   - DEX (Dalvik Executable): Os arquivos `.dex` contêm o código de byte compilado que é executado pela **Android** Runtime (ART).
   - ELF: Para código nativo (C/C++), o **Android** utiliza o formato ELF, da mesma forma que o Linux.
   - `.aab` (Android App Bundle): O formato de publicação de aplicativos na Google Play Store. O AAB inclui todo o código e recursos do aplicativo, mas a Google Play o utiliza para gerar e servir APKs otimizados para a configuração de cada dispositivo.

#### A Sociedade dos Processos: Tipos e Funções no Sistema Operacional

Compreender que nem todos os processos são criados iguais é essencial para diagnosticar problemas, gerenciar o desempenho e entender a segurança do sistema. Eles podem ser classificados de acordo com seu propósito, privilégio e interação com o usuário. A seguir, apresentamos os principais tipos de processos encontrados nos **Sistemas Operacionais** modernos que interagem diretamente com as tarefas definidas pelo usuário.

1. **Processos de Usuário (User Processes)**: são processos iniciados direta ou indiretamente por um usuário logado no **Sistema Operacional**. Processos de usuário rodam no espaço do usuário, em inglês _user space_, uma área da memória com privilégios limitados, o que significa que não podem acessar diretamente o hardware ou interferir com processos críticos do sistema.

2. **Processos de Primeiro Plano (Foreground)**: são os processos com os quais o usuário interage diretamente. Eles possuem uma interface gráfica (ou estão atrelados a um terminal de comando ativo, `shell`. São os aplicativos que você "vê" em execução. Um navegador web (Chrome, Firefox), um editor de texto (VS Code, Bloco de Notas), um player de música ou um jogo são exemplos de processos de primeiro plano.

3. **Processos de Segundo Plano (Background)**: são processos que rodam sem uma interface direta, muitas vezes iniciados por um aplicativo de primeiro plano para executar uma tarefa específica. Neste caso, os exemplos incluem: um cliente de e-mail sincronizando suas mensagens, um programa antivírus realizando uma varredura agendada,  o processo que um navegador cria para baixar um arquivo grande enquanto você continua a navegar.

Além dos processos definidos diretamente pelas ações e necessidades do usuário, existem os processos de sistema. Estes são processos iniciados pelo próprio **Sistema Operacional** durante a inicialização,  para funções de manutenção e integração, e que podem rodar de forma contínua para manter o sistema funcional provendo serviços essenciais. Processos de sistema existem independentemente de haver um usuário logado. Entre eles, destacamos:

1. **Daemons (Linux/macOS) e Serviços (Windows)**: esta é a categoria mais importante de processos de sistema. Eles operam em segundo plano para realizar tarefas fundamentais. Nos sistemas Linux/macOS são chamados de `daemons`. Estes processos gerenciam a rede (`sshd`), agendam tarefas (`cron` ou `launchd`), gerenciam a interface gráfica, entre muitas outras coisas. O processo `systemd`, em muitas distribuições **Linux**, e o `launchd`, no macOS, são os "pais" de quase todos os outros `daemons` e processos do sistema. No **Windows** estes processos são chamados de _Serviços_. Estes processos realizam funções análogas. O processo `svchost.exe` é um anfitrião genérico que pode executar múltiplos serviços para economizar recursos. Outros exemplos incluem `lsass.exe` que gerencia a segurança e o login e o `services.exe`, o gerenciador de controle de serviços.

2. **Threads do Kernel**:: em um nível ainda mais baixo, o próprio `kernel` executa `threads` especiais que não são processos de usuário completos. Eles lidam com tarefas internas de baixo nível, como gerenciamento de memória, operações de `E/S` e agendamento e despacho de outros processos. No **Linux**, por exemplo, o processo `kthreadd` é responsável por criar essas outras `threads` do `kernel`. Os `threads` serão estudados mais adiante, mas é importante notar que eles são uma parte fundamental do funcionamento interno do **Sistema Operacional**.

##### A Hierarquia e o Relacionamento entre Processos

Os processos em sistemas como **Linux** e macOS existem em uma hierarquia clara, uma árvore genealógica onde cada processo tem um pai. Esta estrutura é importante por motivos de segurança e políticas de segurança. Nesta genealogia de execução temos:

1. **Processo Pai e Processo Filho (Parent/Child)**: quando um processo cria outro, por exemplo, quando você digita um comando no terminal ou dá um clique duplo em um ícone, o processo original é o Pai e o novo é o Filho. O processo filho herda muitas propriedades do pai, como variáveis de ambiente e permissões. Este modelo é a base dos processos de multitarefa nesses sistemas.

2. **Processos Órfãos (Orphan Processes)**: se um processo pai termina antes de seu processo filho, o filho se torna um órfão. Para evitar que ele fique perdido, o **Sistema Operacional** o adota automaticamente. No **Linux**, o processo `systemd` (PID 1) se torna o novo pai desses órfãos.

3. **Processos Zumbis (Zombie Processes)**: quando um processo filho termina, ele não desaparece completamente. Ele se torna um zumbi. Sua entrada na tabela de processos do sistema é mantida para que o processo pai possa ler seu status de saída, se terminou com sucesso ou com erro. O processo pai deve ler o zumbi para liberá-lo completamente. Zumbis são normais por um curto período, mas um grande acúmulo pode indicar um problema no programa pai.

A criação de processos, a genealogia de processos e toda estrutura de criação de processos é gerenciada pelo **Sistema Operacional**. O processo de criação de um novo processo é chamado de `fork`, que cria uma cópia do processo pai, e o processo filho pode então executar um programa diferente usando a chamada `exec`. O `fork` cria uma cópia exata do processo pai, incluindo seu espaço de endereçamento, mas com um novo identificador de processo (PID). A seguir, o filho pode substituir seu espaço de endereçamento com um novo programa usando `exec`, que carrega um novo executável no espaço do processo filho. Contudo, antes de nos aprofundarmos nos processos, a curiosa leitora precisa conhecer os `threads`.

### Threads {#sec-thread1}

os `threads` são uma evolução no conceito de execução concorrente, permitindo que múltiplas linhas de execução operem dentro de um mesmo processo, compartilhando o mesmo espaço de endereçamento de memória. Diferentemente dos processos, que exigem trocas de contexto computacionalmente caras, envolvendo atualizações completas de gerenciamento de memória, os `threads` compartilham o segmento de texto, dados e ``heap``, requerendo apenas atualizações de registradores e ponteiros de `stack` durante trocas de contexto. A @tbl-threads2 mostra uma comparação entre processos e `threads`.

| Característica | Processo | Thread |
|---|---|---|
| **Compartilhamento de Recursos** | Não compartilha memória diretamente com outros processos; cada um tem seu próprio espaço de endereço virtual. | Compartilha o espaço de endereço (código, dados, `heap`) e outros recursos (arquivos abertos) com outras threads do mesmo processo. |
| **Tempo de Criação** | Leva mais tempo para ser criado, pois envolve a alocação de um novo espaço de endereço e estruturas de dados. | Leva menos tempo para ser criada, pois utiliza o espaço de endereço existente do processo pai. |
| **Sobrecarga de Troca de Contexto** | Maior sobrecarga, pois a troca de contexto envolve a mudança de todo o espaço de endereço virtual e do estado do hardware. | Menor sobrecarga, pois a troca de contexto ocorre dentro do mesmo espaço de endereço, exigindo apenas a troca de registradores e da pilha. |
| **Independência** | Processos são independentes; a falha de um processo geralmente não afeta outros. | Threads não são completamente independentes; a falha de uma thread pode afetar outras threads do mesmo processo. |
| **Comunicação** | A comunicação entre processos (IPC) é mais complexa e requer mecanismos específicos. | A comunicação entre threads é mais simples, pois elas compartilham a memória, permitindo acesso direto aos dados. |

: Comparação entre as características entre processos e `threads`. {#tbl-threads2}

A criação de threads é geralmente mais rápida que a criação de processos, pois threads compartilham o mesmo espaço de memória. Um estudo de 2018 mediu o tempo de criação de processos em $35 µs$$ e de `threads` em $5 µs$ para um ``heap`` de $2 MB$, resultando em `threads` $7$ vezes mais rápidos. Outro benchmark de 2017 indicou que a criação de threads é $2$ a $3$ vezes mais rápida que a criação de processos. O mesmo benchmark de 2017 mostrou que a criação de threads é $7$ a $8$ vezes mais rápida que a de processos.A diferença no tempo de criação varia devido ao tamanho do contexto de execução e à implementação específica do **Sistema Operacional**. A @tbl-thread1 mostra alguns benchmarks de criação de processos e threads em diferentes **Sistemas Operacionais**.

| **Sistema Operacional** | Tempo de Criação de Processo (µs) | Tempo de Criação de `Thread` (µs) | Razão (`Thread` mais rápido) |
|---------------------|-----------------------------------|---------------------------------|------------------------------|
| **Linux** (2018, 2 MB) | 35        | 5        | 7       |
| **Linux** (2017)  | não indicado no estudo   | não indicado no estudo   | 2-3       |
| macOS (2017)  | não indicado no estudo   | não indicado no estudo   | 7-8       |

: Benchmarks comparativos de criação de processos e threads. {#tbl-thread1}

O conceito de `threads` surgiu para atender à necessidade de maior eficiência na execução concorrente, especialmente em sistemas com múltiplos processadores. Inicialmente, a concorrência era alcançada por meio de processos separados, mas os altos custos de troca de contexto e o isolamento de memória limitavam a performance. Na década de 1980, com o avanço dos **Sistemas Operacionais** e arquiteturas de hardware, as `threads` começaram a ser implementadas como uma solução leve, permitindo que múltiplas tarefas fossem executadas simultaneamente dentro de um mesmo processo. Essa abordagem ganhou tração com sistemas como [POSIX Threads](https://hpc-tutorials.llnl.gov/posix/), `Pthreads` e a popularização de modelos `multithreading` em **Sistemas Operacionais** modernos.

#### Modelos de Multithreading

A evolução dos modelos de `multithreading` reflete o esforço contínuo para equilibrar desempenho, paralelismo e complexidade de implementação. Os principais modelos incluem:

1. **Many-to-One**: nesse modelo, várias `threads` de usuário são mapeadas para uma única `thread` do ``Kernel`` . Ele é eficiente, pois o gerenciamento ocorre no espaço do usuário, mas apresenta limitações: uma chamada de sistema bloqueante pode travar todas as `threads` do processo, reduzindo o paralelismo.
2. **One-to-One**: cada `thread` de usuário é mapeada para uma `thread` do ``Kernel``, permitindo verdadeiro paralelismo, especialmente em sistemas com múltiplos núcleos. No entanto, o envolvimento do ``Kernel`` aumenta o *overhead* de gerenciamento.
3. **Many-to-Many**: considerado o modelo mais avançado, mapeia dinamicamente `threads` de usuário para `threads` do ``Kernel`` , combinando eficiência e paralelismo. Apesar de sua sofisticação, a complexidade de implementação ainda restringe sua adoção em larga escala.

Essa evolução demonstra como as `threads` transformaram a computação moderna, oferecendo uma solução flexível e eficiente para a execução concorrente, adaptada às demandas de **Sistemas Operacionais** e aplicações cada vez mais complexas.

## Processos a Nível de Usuário: Nascimento, Vida e Morte de Tarefas

Um processo é a unidade fundamental de execução de sistemas computacionais gerenciados por um **Sistema Operacional**, representando uma instância de um programa em andamento.

Como vamos começar estudando processos de usuário. Para criar um processo a esforçada leitora pode, simplesmente, dar dois cliques rápidos com o m se em um ícone de aplicativo na tela da sua máquina. Ou, se for um pouco mais audaciosa, pode abrir um terminal e digitar um comando como `./meu_programa` e teclar `Enter`. Nestes dois casos existem duas possibilidades,  o **Sistema Operacional** entende o clique duplo e o comando e cria um processo,  ele indica um erro. Nos dois casos restam algumas dúvidas. A mais importante delas é: como o **Sistema Operacional** transforma esse comando em uma tarefa em execução? Vamos explorar os fundamentos do gerenciamento de processos, desde a criação até a finalização, passando por conceitos essenciais como espaço de endereçamento virtual, tabelas de páginas e o ciclo de vida de um processo.

Se a corajosa leitora desejar pode tentar criar o seu próprio processo do zero. Para isso precisará ter configurado o seu próprio ambiente de desenvolvimento. Eu recomendo que, no **Linux**, você use o [Visual Studio Code](https://code.visualstudio.com/) como editor de código, o [CMake](https://cmake.org/) como sistema de construção e o [LLVM](https://llvm.org/) como compilador. No Windows, você pode montar um ambiente parecido com esse ou, simplesmente usar o Visual Studio com o [Visual Studio Build Tools](https://visualstudio.microsoft.com/visual-cpp-build-tools/) e o [CMake](https://cmake.org/). No macOS, você pode usar o Visual Studio Code com o [Xcode Command Line Tools](https://developer.apple.com/xcode/features/) e o [CMake](https://cmake.org/).

### Meu primeiro Processo Windows 11

Os programas **Windows** são executados como processos, e o **Sistema Operacional** **Windows** 11 fornece uma API rica para criar e gerenciar esses processos. Fazer um _Hello World_ seria denegrir a capacidade da esforçada leitora. Sendo assim, a seguir está um exemplo de como listar os processos que estão em execução em uma máquina rodando **Windows** 11, usando a API do **Windows** em C++23:

::: {#lst-cppwindows1}

```cpp
/**
 * @file process_lister.cpp
 * @brief Programa para listar processos em execução no **Windows** 11
 * @author Livro de Sistemas Operacionais
 * @version 1.
 * @date 2025
 * 
 * Este programa demonstra como enumerar processos em execução usando
 * a **Windows** API em C++23. 
 */

#include <windows.h>    // API principal do **Windows** - fornece tipos básicos (DWORD, HANDLE) 
                        // e funções do sistema como OpenProcess(), CloseHandle()

#include <psapi.h>      // Process Status API - funções específicas para enumeração de processos:
                        // EnumProcesses(), EnumProcessModules(), GetModuleBaseNameW(),
                        // GetProcessMemoryInfo(), QueryFullProcessImageNameW()

#include <iostream>     // Fluxos de entrada/saída padrão - std::wcout, std::wcerr, std::wcin
                        // para exibição de texto Unicode na console

#include <vector>       // Contêiner dinâmico std::vector para armazenar listas de ProcessInfo
                        // e arrays de IDs de processos retornados pela API

#include <string>       // std::wstring para manipulação de strings Unicode (nomes e caminhos
                        // de processos que podem conter caracteres especiais)

#include <format>       // std::format (C++20) - formatação moderna de strings tipo printf
                        // mas type-safe para criar tabelas e exibições formatadas

#include <ranges>       // std::ranges (C++20) - algoritmos funcionais modernos como
                        // ranges::sort(), ranges::copy_if() para manipulação de dados

#include <algorithm>    // Algoritmos STL complementares e std::back_inserter para
                        // operações auxiliares de manipulação de contêineres

#include <memory>       // Smart pointers e utilitários de gerenciamento de memória
                        // (incluído para possíveis extensões futuras do código)

// não espere que eu vá comentar as bibliotecas novamente. Esta foi uma concessão por ser 
// nosso primeiro código.

/**
 * @brief Estrutura para armazenar informações de um processo
 * 
 * Esta estrutura encapsula as informações básicas de um processo
 * que serão coletadas e exibidas pelo programa.
 */
struct ProcessInfo {
    DWORD processId;           ///< ID do processo (PID)
    std::wstring processName;  ///< Nome do executável do processo
    std::wstring fullPath;     ///< Caminho completo do executável
    SIZE_T workingSetSize;     ///< Tamanho do working set em bytes
    
    /**
    O Tamanho do working representa a quantidade de memória física (RAM) que está atualmente sendo utilizada por um processo específico. Em **Sistemas Operacionais** com memória virtual como o Windows, o working set é o conjunto de páginas de memória que estão fisicamente residentes na `RAM` para aquele processo em um determinado momento
    **/

    /**
     * @brief Construtor padrão
     */
    ProcessInfo() : processId(0), workingSetSize(0) {}
    
    /**
     * @brief Construtor com parâmetros
     * @param **PID** ID do processo
     * @param name Nome do processo
     * @param path Caminho completo
     * @param memSize Tamanho da memória em uso
     */
    ProcessInfo(DWORD pid, const std::wstring& name, 
                const std::wstring& path, SIZE_T memSize)
        : processId(pid), processName(name), fullPath(path), workingSetSize(memSize) {}
};

/**
 * @brief Classe responsável por enumerar e gerenciar informações de processos
 * 
 * Esta classe encapsula toda a funcionalidade relacionada à coleta
 * de informações sobre processos em execução no sistema Windows.
 */
class ProcessEnumerator {
private:
    std::vector<ProcessInfo> processes; ///< Lista de processos coletados
    
    /**
     * @brief Obtém o nome do processo a partir de seu handle
     * @param hProcess Handle do processo
     * @return Nome do processo ou string vazia em caso de erro
     */
    std::wstring getProcessName(HANDLE hProcess) const {
        wchar_t processName[MAX_PATH] = L"<desconhecido>";
        
        if (hProcess != nullptr) {
            HMODULE hMod;
            DWORD cbNeeded;
            
            if (EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded)) {
                GetModuleBaseNameW(hProcess, hMod, processName, 
                                   sizeof(processName) / sizeof(wchar_t));
            }
        }
        
        return std::wstring(processName);
    }
    
    /**
     * @brief Obtém o caminho completo do executável do processo
     * @param hProcess Handle do processo
     * @return Caminho completo ou string vazia em caso de erro
     */
    std::wstring getProcessPath(HANDLE hProcess) const {
        wchar_t processPath[MAX_PATH] = L"<caminho não disponível>";
        
        if (hProcess != nullptr) {
            DWORD pathLength = MAX_PATH;
            if (!QueryFullProcessImageNameW(hProcess, 0, processPath, &pathLength)) {
                wcscpy_s(processPath, L"<acesso negado>");
            }
        }
        
        return std::wstring(processPath);
    }
    
    /**
     * @brief Obtém informações de memória do processo
     * @param hProcess Handle do processo
     * @return Tamanho do working set em bytes
     */
    SIZE_T getProcessMemoryInfo(HANDLE hProcess) const {
        PROCESS_MEMORY_COUNTERS pmc;
        
        if (hProcess != nullptr && GetProcessMemoryInfo(hProcess, &pmc, sizeof(pmc))) {
            return pmc.WorkingSetSize;
        }
        
        return 0;
    }

public:
    /**
     * @brief Enumera todos os processos em execução no sistema
     * @return true se a enumeração foi bem-sucedida, false caso contrário
     * 
     * Este método coleta informações sobre todos os processos em execução
     * usando as `APIs`EnumProcesses e OpenProcess do Windows.
     */
    bool enumerateProcesses() {
        // Limpa a lista anterior
        processes.clear();
        
        // Buffer para armazenar os IDs dos processos
        std::vector<DWORD> processIds(1024);
        DWORD bytesReturned;
        
        // Enumera todos os processos
        if (!EnumProcesses(processIds.data(), 
                          static_cast<DWORD>(processIds.size() * sizeof(DWORD)), 
                          &bytesReturned)) {
            std::wcerr << L"Erro ao enumerar processos: " << GetLastError() << std::endl;
            return false;
        }
        
        // Calcula o número de processos retornados
        DWORD processCount = bytesReturned / sizeof(DWORD);
        
        // Processa cada ID de processo
        for (DWORD i = 0; i < processCount; ++i) {
            DWORD processId = processIds[i];
            
            // Abre o processo com permissões limitadas
            HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, 
                                        FALSE, processId);
            
            if (hProcess != nullptr) {
                // Coleta informações do processo
                auto name = getProcessName(hProcess);
                auto path = getProcessPath(hProcess);
                auto memSize = getProcessMemoryInfo(hProcess);
                
                // Adiciona à lista usando emplace_back (C++ 11+)
                processes.emplace_back(processId, name, path, memSize);
                
                CloseHandle(hProcess);
            } else {
                // Processo sem acesso - adiciona informações básicas
                processes.emplace_back(processId, L"<acesso negado>", 
                                     L"<acesso negado>", 0);
            }
        }
        
        return true;
    }
    
    /**
     * @brief Exibe a lista de processos formatada
     * 
     * Utiliza std::format (C++ 20) e ranges (C++ 20) para formatação
     * e manipulação dos dados de forma moderna.
     */
    void displayProcesses() const {
        // Cabeçalho da tabela
        std::wcout << std::format(L"{:>8} | {:30} | {:10} | {}\n", 
                                 L"PID", L"Nome do Processo", L"Memória (KB)", L"Caminho");
        std::wcout << std::wstring(80, L'-') << std::endl;
        
        // Ordena os processos por **PID** usando ranges (C++ 20)
        auto sortedProcesses = processes;
        std::ranges::sort(sortedProcesses, 
                         [](const ProcessInfo& a, const ProcessInfo& b) {
                             return a.processId < b.processId;
                         });
        
        // Exibe cada processo
        for (const auto& proc : sortedProcesses) {
            // Converte bytes para KB
            SIZE_T memoryKB = proc.workingSetSize / 1024;
            
            std::wcout << std::format(L"{:8} | {:30} | {:10} | {}\n",
                                     proc.processId,
                                     proc.processName.substr(0, 30),
                                     memoryKB,
                                     proc.fullPath);
        }
        
        std::wcout << std::format(L"\nTotal de processos: {}\n", processes.size());
    }
    
    /**
     * @brief Obtém estatísticas dos processos
     * @return Par contendo número total de processos e uso total de memória
     */
    std::pair<size_t, SIZE_T> getStatistics() const {
        SIZE_T totalMemory = 0;
        
        // Usa ranges::fold_left (C++23) para somar a memória total
        for (const auto& proc : processes) {
            totalMemory += proc.workingSetSize;
        }
        
        return {processes.size(), totalMemory};
    }
    
    /**
     * @brief Filtra processos por nome
     * @param namePattern Padrão do nome para filtrar
     * @return Vetor com processos que correspondem ao padrão
     */
    std::vector<ProcessInfo> filterByName(const std::wstring& namePattern) const {
        std::vector<ProcessInfo> filtered;
        
        // Usa ranges::copy_if (C++ 20) para filtragem
        std::ranges::copy_if(processes, std::back_inserter(filtered),
                            [&namePattern](const ProcessInfo& proc) {
                                return proc.processName.find(namePattern) != std::wstring::npos;
                            });
        
        return filtered;
    }
};

/**
 * @brief Função principal do programa
 * @return Código de saída (0 para sucesso)
 * 
 * Demonstra o uso da classe ProcessEnumerator para listar
 * processos em execução no sistema Windows.
 */
int main() {
    // Configura a saída para suportar caracteres Unicode
    std::wcout.imbue(std::locale(""));
    
    std::wcout << L"=== Listador de Processos **Windows** - C++23 ===" << std::endl;
    std::wcout << L"Coletando informações dos processos..." << std::endl << std::endl;
    
    // Cria o enumerador de processos
    ProcessEnumerator enumerator;
    
    // Enumera os processos
    if (!enumerator.enumerateProcesses()) {
        std::wcerr << L"Falha ao enumerar processos!" << std::endl;
        return 1;
    }
    
    // Exibe os processos
    enumerator.displayProcesses();
    
    // Exibe estatísticas
    auto [processCount, totalMemory] = enumerator.getStatistics();
    std::wcout << std::format(L"\nEstatísticas:\n");
    std::wcout << std::format(L"- Processos em execução: {}\n", processCount);
    std::wcout << std::format(L"- Memória total em uso: {:.f} MB\n", 
                             static_cast<double>(totalMemory) / (1024 * 1024));
    
    // Exemplo de filtragem (opcional)
    std::wcout << L"\nPressione Enter para ver exemplo de filtragem...";
    std::wcin.get();
    
    auto svcProcesses = enumerator.filterByName(L"svc");
    if (!svcProcesses.empty()) {
        std::wcout << std::format(L"\nProcessos com 'svc' no nome ({} encontrados):\n", 
                                 svcProcesses.size());
        for (const auto& proc : svcProcesses) {
            std::wcout << std::format(L"- **PID** {}: {}\n", 
                                     proc.processId, proc.processName);
        }
    }
    
    return 0;
}
```

:::

O código listado em @lst-cppwindows1, implementa um sistema para enumerar e exibir informações sobre processos em execução no **Windows** 11, utilizando uma abordagem orientada a objetos. A estrutura principal está organizada em torno da classe `ProcessEnumerator`, que encapsula toda a funcionalidade de coleta e manipulação de dados dos processos. O programa também define uma estrutura `ProcessInfo` que serve como contêiner para as informações essenciais de cada processo, incluindo a identificação do processo, em inglês **P**rocess **ID**entification, **PID** do processo (`processId`), nome do executável (`processName`), caminho completo (`fullPath`) e uso de memória (`workingSetSize`). Neste código, o objetivo é permitir uma separação de responsabilidades e facilitar o entendimento, a manutenção e, se a audaciosa leitora desejar, a extensão do código.

A coleta das informações dos processos será realizada pelo método `enumerateProcesses()`, que utiliza a API `EnumProcesses()` do **Windows** para obter uma lista de todos os IDs de processos ativos no sistema. Para cada processo encontrado, o programa tenta abrir um `handle` usando `OpenProcess()` com permissões específicas (`PROCESS_QUERY_INFORMATION | PROCESS_VM_READ`) e então extrai informações detalhadas por meio de três métodos auxiliares: `getProcessName()` usa `EnumProcessModules()` e `GetModuleBaseNameW()` para obter o nome do executável, `getProcessPath()` utiliza `QueryFullProcessImageNameW()` para recuperar o caminho completo, e `getProcessMemoryInfo()` emprega `GetProcessMemoryInfo()` para coletar estatísticas de uso de memória. O programa implementa algum tratamento de erros, e tenta lidar adequadamente com processos que podem ter acesso restrito devido a permissões do sistema.

::: callout-note
**O que é um handle?**
Um handle (manipulador) é um identificador opaco retornado pelo **Sistema Operacional** que representa um recurso do sistema, como processos, arquivos, threads,  objetos de sincronização. No contexto deste programa, o handle obtido através de 
`OpenProcess()` funciona como uma "chave de acesso" que permite ao programa interagir com um processo específico através das `APIs`do Windows.
:::

Quando chamamos `OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processId)`, o **Sistema Operacional** verifica as permissões e, se aprovadas, retorna um valor do tipo `HANDLE` que referencia internamente as estruturas de dados do `kernel` relacionadas àquele processo. Este `handle` não é um ponteiro direto, é um índice para uma tabela interna do **Sistema Operacional** que mapeia o objeto real. A @fig-meuprocesso1 apresenta um diagrama dos acessos feitos pelo código da @lst-cppwindows1.

:::{#fig-meuprocesso1}
![Diagrama de Acessos aos Processos](images/meuProcesso1.webp)

Diagrama de dados mostrando o fluxo de dados entre o programa, o sistemas operacional e o hardware.
:::

É fundamental fechar todo `handle` obtido usando `CloseHandle()` ao final de sua utilização, pois handles são recursos limitados do sistema. Falhar em liberá-los pode causar vazamentos de recursos, _resource leaks_ que, em casos extremos, podem esgotar a capacidade do sistema de criar novos `handles`. O padrão **R**esource **A**cquisition **I**s **I**nitialization, **RAII** do C++ pode ser usado com classes _wrapper_ para garantir liberação automática de `handles`.

A exibição dos dados coletados será feita pelo método `displayProcesses()`, que demonstra o uso de recursos modernos do C++ como `std::format` para formatação elegante de _strings_ e `std::ranges::sort` para ordenação funcional dos processos por **PID**. O programa também oferece o método `getStatistics()` que calcula estatísticas gerais do sistema usando _structured bindings_, e o método `filterByName()` que implementa filtragem de processos usando `std::ranges::copy_if`. A função `main()` orquestra todo o fluxo do programa, configurando adequadamente a saída Unicode com `std::wcout.imbue(std::locale(""))`, não me preocupei com saídas corretamente acentuadas em português, e demonstrando o uso prático de todas as funcionalidades implementadas.

O código utiliza características avançadas do C++ disponíveis a partir do C++20. A implementação garante que `handles` de processos sejam adequadamente fechados com `CloseHandle()`, evitando vazamentos de recursos, e usa técnicas modernas como `emplace_back()` para construção eficiente de objetos diretamente no contêiner. Este programa serve como uma demonstração de como interfaces de sistema de baixo nível podem ser encapsuladas em código C++ moderno, mantendo tanto a eficiência quanto a legibilidade e manutenibilidade. Ao executar este código a leitora verá, no terminal uma lista de processos algo como:

::: {#lst-shell1}

```shell
     **PID** | Nome do Processo               | Memória (KB) | Caminho
--------------------------------------------------------------------------------
   ...
   ...
   ...
   27664 | <acesso negado>                |          0 | <acesso negado>
   27836 | CrossDeviceResume.exe          |       5056 | C:\Windows\SystemApps\MicrosoftWindows.Client...DeviceResume.exe
   27964 | FileCoAuth.exe                 |      14016 | C:\Program Files\Microsoft ...\FileCoAuth.exe
   28008 | AdobeCollabSync.exe            |      19808 | C:\Program Files\Adobe\Acrobat DC\Acrobat\AdobeCollabSync.exe
   28088 | PerfWatson2.exe                |      58092 | C:\Program Files\Microsoft Visual Studio\2022\... d.exe
   28120 | ServiceHub.IndexingService.exe |      61888 | C:\Program ...o\2022\Community\...IndexingService.exe
   28288 | msedge.exe                     |      10240 | C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe
   28520 | <acesso negado>                |          0 | <acesso negado>
   28556 | msedge.exe                     |       6832 | C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe

Total de processos: 322

Estatísticas:
- Processos em execução: 322
- Memória total em uso: 7293. MB
```
:::

A listagem @lst-shell1 foi manualmente editada, eu encurtei os caminhos, paths em inglês, para que coubessem na página e também limitei a listagem aos últimos processos que estão rodando na minha máquina **Windows** 11, neste momento em que escrevo, rodo códigos de teste faço buscas na web e em sistemas de inteligência artificial. Como a atenta leitora percebeu, neste momento minha máquina está rodando $322$ processos usando um quarto da capacidade de memória da minha máquina. Observe também que alguns dos processos estão com o `acesso negado`, isso acontece porque o programa não tem permissão para acessar os detalhes desses processos. Outros processos, como o `msedge.exe`, são executáveis comuns que a leitora pode reconhecer como parte do navegador Microsoft Edge.

::: {.content-hidden when-format="pdf"}
:::{.callout-tip}
Você pode ver um resumo do @lst-cppwindows1 no [Expresso](.\ex\gerproc1-expresso.html).
:::
:::


### Meu Primeiro Processo Linux

Os programas nos **Sistemas Operacionais** que rodam o `Kernel` **Linux** são executados como processos, e o **Sistema Operacional** também **Linux** fornece uma API rica para criar e gerenciar esses processos. Sendo assim, a seguir está um exemplo de como listar os processos que estão em execução em uma máquina rodando **Linux**, usando a API do **Linux** em C++23.

::: {#lst-cpplinux1}

```cpp
/**
 * @file process_lister_linux.cpp
 * @brief Programa para listar processos em execução no Ubuntu/Linux
 * @author Livro de Sistemas Operacionais
 * @version 1.
 * @date 2025
 * 
 * Este programa demonstra como enumerar processos em execução usando
 * o filesystem /proc do **Linux** em C++23. É adequado para estudo de 
 * **Sistemas Operacionais** e demonstra conceitos de gerenciamento de processos.
 */

#include <iostream>     // Fluxos de entrada/saída padrão - std::cout, std::cerr, std::cin
                        // para exibição de texto na console (sem Unicode como no Windows)

#include <vector>       // Contêiner dinâmico std::vector para armazenar listas de ProcessInfo
                        // e manipular coleções de processos de forma eficiente

#include <string>       // std::string para manipulação de strings ASCII (nomes de processos,
                        // caminhos, linhas de comando lidas dos arquivos /proc)

#include <format>       // std::format (C++20) - formatação moderna type-safe para criar
                        // tabelas e exibições formatadas dos dados dos processos

#include <ranges>       // std::ranges (C++20) - algoritmos funcionais como ranges::sort(),
                        // ranges::copy_if(), ranges::partial_sort() para manipulação de dados

#include <algorithm>    // Algoritmos STL complementares e std::back_inserter para operações
                        // auxiliares de manipulação de contêineres

#include <filesystem>   // std::filesystem (C++17) - navegação pelo diretório /proc para
                        // enumerar processos através do sistema de arquivos

#include <fstream>      // std::ifstream para leitura de arquivos como /proc/[pid]/comm,
                        // /proc/[pid]/cmdline, /proc/[pid]/status

#include <sstream>      // std::istringstream para parsing de linhas dos arquivos /proc/[pid]/status
                        // extraindo campos específicos como Uid, VmSize, VmRSS

#include <unistd.h>     // Funções POSIX do sistema - getpid() para obter **PID** atual,
                        // getuid() para obter UID do usuário atual

#include <sys/types.h>  // Tipos de dados do sistema POSIX - pid_t para IDs de processo,
                        // uid_t para IDs de usuário

#include <dirent.h>     // Interface para manipulação de diretórios (incluído mas não usado
                        // diretamente - std::filesystem é usado no lugar)

#include <cctype>       // Funções de classificação de caracteres - ::isdigit() para verificar
                        // se strings representam números (PIDs) nos nomes de diretórios

#include <optional>     // std::optional (C++17) para valores opcionais (incluído para possíveis
                        // extensões futuras que podem retornar valores nulos)

// deleite-se, esta foi a última vez que comentei as bibliotecas.

/**
 * @brief Estrutura para armazenar informações de um processo
 * 
 * Esta estrutura encapsula as informações básicas de um processo
 * que serão coletadas através do filesystem /proc do Linux.
 */
struct ProcessInfo {
    pid_t processId;              ///< ID do processo (PID)
    std::string processName;      ///< Nome do processo
    std::string commandLine;      ///< Linha de comando completa
    std::string state;            ///< Estado do processo (R, S, Z, etc.)
    size_t virtualMemory;         ///< Memória virtual em KB
    size_t residentMemory;        ///< Memória residente (RSS) em KB
    uid_t userId;                 ///< ID do usuário dono do processo
    
    /**
     * @brief Construtor padrão
     */
    ProcessInfo() : processId(0), virtualMemory(0), residentMemory(0), userId(0) {}
    
    /**
     * @brief Construtor com parâmetros
     * @param **PID** ID do processo
     * @param name Nome do processo
     * @param cmdline Linha de comando
     * @param st Estado do processo
     * @param vmem Memória virtual
     * @param rmem Memória residente
     * @param uid ID do usuário
     */
    ProcessInfo(pid_t pid, const std::string& name, const std::string& cmdline,
                const std::string& st, size_t vmem, size_t rmem, uid_t uid)
        : processId(pid), processName(name), commandLine(cmdline), 
          state(st), virtualMemory(vmem), residentMemory(rmem), userId(uid) {}
};

/**
 * @brief Classe responsável por enumerar e gerenciar informações de processos no Linux
 * 
 * Esta classe encapsula toda a funcionalidade relacionada à coleta
 * de informações sobre processos através do filesystem /proc.
 */
class LinuxProcessEnumerator {
private:
    std::vector<ProcessInfo> processes; ///< Lista de processos coletados
    
    /**
     * @brief Verifica se uma string representa um número (PID)
     * @param str String a ser verificada
     * @return true se a string contém apenas dígitos
     */
    bool isNumeric(const std::string& str) const {
        return !str.empty() && std::ranges::all_of(str, ::isdigit);
    }
    
    /**
     * @brief Lê o nome do processo do arquivo /proc/[pid]/comm
     * @param **PID** ID do processo
     * @return Nome do processo ou string vazia em caso de erro
     */
    std::string getProcessName(pid_t pid) const {
        std::ifstream commFile(std::format("/proc/{}/comm", pid));
        std::string name;
        
        if (commFile.is_open()) {
            std::getline(commFile, name);
            // Remove quebra de linha se presente
            if (!name.empty() && name.back() == '\n') {
                name.pop_back();
            }
        }
        
        return name.empty() ? "<desconhecido>" : name;
    }
    
    /**
     * @brief Lê a linha de comando do processo do arquivo /proc/[pid]/cmdline
     * @param **PID** ID do processo
     * @return Linha de comando ou string vazia em caso de erro
     */
    std::string getCommandLine(pid_t pid) const {
        std::ifstream cmdlineFile(std::format("/proc/{}/cmdline", pid));
        std::string cmdline;
        
        if (cmdlineFile.is_open()) {
            std::string fullCmdline;
            std::getline(cmdlineFile, fullCmdline, '\0');
            
            // Substitui caracteres nulos por espaços para legibilidade
            for (char& c : fullCmdline) {
                if (c == '\0') c = ' ';
            }
            
            cmdline = fullCmdline;
        }
        
        return cmdline.empty() ? "<não disponível>" : cmdline;
    }
    
    /**
     * @brief Obtém informações de status do processo do arquivo /proc/[pid]/status
     * @param **PID** ID do processo
     * @return Tupla com estado, UID, VmSize e VmRSS
     */
    std::tuple<std::string, uid_t, size_t, size_t> getProcessStatus(pid_t pid) const {
        std::ifstream statusFile(std::format("/proc/{}/status", pid));
        std::string line;
        std::string state = "?";
        uid_t uid = 0;
        size_t vmSize = 0, vmRSS = 0;
        
        while (statusFile.is_open() && std::getline(statusFile, line)) {
            std::istringstream iss(line);
            std::string key;
            iss >> key;
            
            if (key == "State:") {
                iss >> state;
            } else if (key == "Uid:") {
                iss >> uid;
            } else if (key == "VmSize:") {
                iss >> vmSize;
            } else if (key == "VmRSS:") {
                iss >> vmRSS;
            }
        }
        
        return {state, uid, vmSize, vmRSS};
    }
    
    /**
     * @brief Converte estado do processo para descrição legível
     * @param state Código do estado (R, S, D, Z, etc.)
     * @return Descrição do estado
     */
    std::string getStateDescription(const std::string& state) const {
        if (state == "R") return "Executando";
        if (state == "S") return "Dormindo";
        if (state == "D") return "Espera `E/S`";
        if (state == "Z") return "Zumbi";
        if (state == "T") return "Parado";
        if (state == "X") return "Morto";
        return "Desconhecido";
    }

public:
    /**
     * @brief Enumera todos os processos em execução no sistema Linux
     * @return true se a enumeração foi bem-sucedida, false caso contrário
     * 
     * Este método lê o diretório /proc para encontrar todos os processos
     * e coleta informações detalhadas de cada um.
     */
    bool enumerateProcesses() {
        processes.clear();
        
        try {
            // Itera sobre todos os diretórios em /proc
            for (const auto& entry : std::filesystem::directory_iterator("/proc")) {
                if (entry.is_directory()) {
                    std::string dirname = entry.path().filename().string();
                    
                    // Verifica se o nome do diretório é um **PID** (número)
                    if (isNumeric(dirname)) {
                        pid_t **PID** = std::stoi(dirname);
                        
                        // Coleta informações do processo
                        auto name = getProcessName(pid);
                        auto cmdline = getCommandLine(pid);
                        auto [state, uid, vmSize, vmRSS] = getProcessStatus(pid);
                        
                        // Adiciona à lista
                        processes.emplace_back(pid, name, cmdline, state, 
                                             vmSize, vmRSS, uid);
                    }
                }
            }
            
            return true;
            
        } catch (const std::filesystem::filesystem_error& e) {
            std::cerr << "Erro ao acessar /proc: " << e.what() << std::endl;
            return false;
        }
    }
    
    /**
     * @brief Exibe a lista de processos formatada
     * 
     * Utiliza std::format (C++ 20) e ranges (C++ 20) para formatação
     * e manipulação dos dados.
     */
    void displayProcesses() const {
        // Cabeçalho da tabela
        std::cout << std::format("{:>8} | {:20} | {:8} | {:10} | {:10} | {:6} | {}\n", 
                                 "PID", "Nome", "Estado", "VM (KB)", "RSS (KB)", "UID", "Comando");
        std::cout << std::string(100, '-') << std::endl;
        
        // Ordena os processos por **PID** usando ranges (C++ 20)
        auto sortedProcesses = processes;
        std::ranges::sort(sortedProcesses, 
                         [](const ProcessInfo& a, const ProcessInfo& b) {
                             return a.processId < b.processId;
                         });
        
        // Exibe cada processo
        for (const auto& proc : sortedProcesses) {
            std::string truncatedCmd = proc.commandLine.substr(0, 30);
            std::string stateDesc = getStateDescription(proc.state);
            
            std::cout << std::format("{:8} | {:20} | {:8} | {:10} | {:10} | {:6} | {}\n",
                                     proc.processId,
                                     proc.processName.substr(0, 20),
                                     stateDesc.substr(0, 8),
                                     proc.virtualMemory,
                                     proc.residentMemory,
                                     proc.userId,
                                     truncatedCmd);
        }
        
        std::cout << std::format("\nTotal de processos: {}\n", processes.size());
    }
    
    /**
     * @brief Obtém estatísticas dos processos
     * @return Tupla com número total, memória virtual e residente total
     */
    std::tuple<size_t, size_t, size_t> getStatistics() const {
        size_t totalVirtualMemory = 0, totalResidentMemory = 0;
        
        for (const auto& proc : processes) {
            totalVirtualMemory += proc.virtualMemory;
            totalResidentMemory += proc.residentMemory;
        }
        
        return {processes.size(), totalVirtualMemory, totalResidentMemory};
    }
    
    /**
     * @brief Filtra processos por nome
     * @param namePattern Padrão do nome para filtrar
     * @return Vetor com processos que correspondem ao padrão
     */
    std::vector<ProcessInfo> filterByName(const std::string& namePattern) const {
        std::vector<ProcessInfo> filtered;
        
        std::ranges::copy_if(processes, std::back_inserter(filtered),
                            [&namePattern](const ProcessInfo& proc) {
                                return proc.processName.find(namePattern) != std::string::npos;
                            });
        
        return filtered;
    }
    
    /**
     * @brief Filtra processos por usuário
     * @param uid ID do usuário
     * @return Vetor com processos do usuário especificado
     */
    std::vector<ProcessInfo> filterByUser(uid_t uid) const {
        std::vector<ProcessInfo> filtered;
        
        std::ranges::copy_if(processes, std::back_inserter(filtered),
                            [uid](const ProcessInfo& proc) {
                                return proc.userId == uid;
                            });
        
        return filtered;
    }
    
    /**
     * @brief Obtém processos com maior uso de memória
     * @param count Número de processos a retornar
     * @return Vetor com os processos que mais consomem memória
     */
    std::vector<ProcessInfo> getTopMemoryConsumers(size_t count = 10) const {
        auto sortedByMemory = processes;
        
        std::ranges::partial_sort(sortedByMemory, 
                                 sortedByMemory.begin() + std::min(count, sortedByMemory.size()),
                                 [](const ProcessInfo& a, const ProcessInfo& b) {
                                     return a.residentMemory > b.residentMemory;
                                 });
        
        return std::vector<ProcessInfo>(sortedByMemory.begin(), 
                                       sortedByMemory.begin() + std::min(count, sortedByMemory.size()));
    }
};

/**
 * @brief Função principal do programa
 * @return Código de saída (0 para sucesso)
 * 
 * Demonstra o uso da classe LinuxProcessEnumerator para listar
 * processos em execução no sistema Linux.
 */
int main() {
    std::cout << "=== Listador de Processos **Linux** - C++23 ===" << std::endl;
    std::cout << "Coletando informações dos processos via /proc..." << std::endl << std::endl;
    
    LinuxProcessEnumerator enumerator;
    
    if (!enumerator.enumerateProcesses()) {
        std::cerr << "Falha ao enumerar processos!" << std::endl;
        return 1;
    }
    
    // Exibe os processos
    enumerator.displayProcesses();
    
    // Exibe estatísticas
    auto [processCount, totalVirtualMem, totalResidentMem] = enumerator.getStatistics();
    std::cout << std::format("\nEstatísticas do Sistema:\n");
    std::cout << std::format("- Processos em execução: {}\n", processCount);
    std::cout << std::format("- Memória virtual total: {:.f} MB\n", 
                             static_cast<double>(totalVirtualMem) / 1024);
    std::cout << std::format("- Memória residente total: {:.f} MB\n", 
                             static_cast<double>(totalResidentMem) / 1024);
    std::cout << std::format("- **PID** do processo atual: {}\n", getpid());
    
    // Exemplo de análises adicionais
    std::cout << "\nPressione Enter para ver análises adicionais...";
    std::cin.get();
    
    // Top 5 processos por uso de memória
    auto topMemory = enumerator.getTopMemoryConsumers(5);
    if (!topMemory.empty()) {
        std::cout << std::format("\nTop 5 processos por uso de memória:\n");
        for (const auto& proc : topMemory) {
            std::cout << std::format("- **PID** {}: {} ({} KB RSS)\n", 
                                     proc.processId, proc.processName, proc.residentMemory);
        }
    }
    
    // Processos do usuário atual
    auto userProcesses = enumerator.filterByUser(getuid());
    std::cout << std::format("\nProcessos do usuário atual (UID {}): {}\n", 
                             getuid(), userProcesses.size());
    
    // Exemplo de filtragem por nome
    auto systemdProcesses = enumerator.filterByName("systemd");
    if (!systemdProcesses.empty()) {
        std::cout << std::format("\nProcessos relacionados ao systemd: {}\n", 
                                 systemdProcesses.size());
    }
    
    return 0;
}

```

:::

O código @lst-cpplinux1 implementa um sistema para enumerar e exibir informações sobre processos em execução no Ubuntu/Linux, utilizando uma abordagem fundamentalmente diferente do **Windows** através do _filesystem virtual_ `/proc`. A estrutura principal continua organizada em torno de uma classe. Neste caso, a classe `LinuxProcessEnumerator`, que encapsula toda a funcionalidade de coleta de dados, mas agora opera lendo arquivos do sistema de arquivos especial `/proc` ao invés de chamar `APIs`diretas do `kernel`. A estrutura `ProcessInfo` foi adaptada para refletir as informações específicas disponíveis no **Linux**, incluindo estados de processo mais detalhados (`state`), separação entre memória virtual (`virtualMemory`) e residente (`residentMemory`), e identificação do usuário proprietário (`userId`). Esta organização mantém os princípios de orientação a objetos enquanto se adapta às características únicas do sistema Linux.

A coleta de informações é realizada através do método `enumerateProcesses()`, que utiliza `std::filesystem::directory_iterator` para percorrer o diretório `/proc` e identificar subdiretórios com nomes numéricos que correspondem aos **PID**s dos processos. Para cada processo encontrado, o programa lê sistematicamente três arquivos principais: `/proc/[pid]/comm` através de `getProcessName()` para obter o nome do executável, `/proc/[pid]/cmdline` via `getCommandLine()` para recuperar a linha de comando completa com argumentos, e `/proc/[pid]/status` usando `getProcessStatus()` para extrair informações detalhadas como estado do processo, UID do proprietário, tamanho da memória virtual e memória residente. O método `getProcessStatus()` implementa parsing sofisticado usando `std::istringstream` para extrair campos específicos do arquivo de status, demonstrando como interfaces textuais podem ser processadas de forma robusta.

A exibição dos dados mantém a elegância do código **Windows** através do método `displayProcesses()`, que continua utilizando `std::format` para formatação e `std::ranges::sort` para ordenação, mas agora inclui informações específicas do **Linux** como estados de processo traduzidos através de `getStateDescription()` que converte códigos como "R", "S", "D", "Z" em descrições legíveis. O programa oferece funcionalidades estendidas como `filterByUser()` que permite filtrar processos por **UID**. No **Linux** o **U**ser **ID**entifier, **UID**, é um número inteiro único atribuído pelo **Sistema Operacional** para identificar cada usuário no sistema. Quando um usuário é criado, o sistema automaticamente lhe atribui um **UID** que permanece constante durante toda a existência daquela conta de usuário. No @lst-cpplinux1 filtramos processos por **UID** usando `std::ranges::copy_if`, e `getTopMemoryConsumers()` que implementa esta análise com `std::ranges::partial_sort` para identificar os processos que mais consomem memória. Novamente, a função `main()` demonstra o uso prático dessas funcionalidades, incluindo análises estatísticas que mostram tanto memória virtual quanto residente, e utiliza funções POSIX como `getpid()` e `getuid()` para contextualizar as informações.

O código exemplifica como os mesmos conceitos fundamentais de **Sistemas Operacionais** podem ser implementados através de interfaces completamente diferentes, contrastando as chamadas diretas de API do **Windows** com a filosofia Unix de _tudo é arquivo_. Finalmente, esta nova implementação garante tratamento de erros através de blocos `try-catch` para `std::filesystem::filesystem_error` e verificações de validade ao abrir arquivos com `std::ifstream`.

::: callout-note
**Tudo é arquivo, mas nem sempre**
A filosofia tudo é arquivo, em inglês _everything is a file_ é um princípio fundamental dos sistemas Unix/Linux nos quais recursos do sistema, dispositivos, processos e informações são expostos como arquivos no sistema de arquivos. No contexto do nosso primeiro programa, esta filosofia se manifesta através do diretório `/proc`, que é um sistema de arquivos virtual em que o `kernel` expõe informações sobre processos em execução como arquivos de texto legíveis. Quando acessamos `/proc/1234/status` ou `/proc/1234/comm`, não estamos lendo arquivos físicos do disco, mas interfaces textuais que o `kernel` gera dinamicamente para representar o estado interno dos processos.

Esta abordagem contrasta fundamentalmente com o **Windows** 11, que utiliza `APIs`binárias diretas através de chamadas de sistema como `OpenProcess()`, `EnumProcesses()` e `GetProcessMemoryInfo()`. No Windows, para obter informações de um processo, o programa deve fazer chamadas específicas que retornam estruturas de dados em formato binário, exigindo conhecimento detalhado dos tipos de dados e handles do sistema. O acesso é controlado através de permissões específicas passadas para `OpenProcess()`, e cada tipo de informação requer uma chamada de API diferente.

A filosofia Unix oferece uniformidade, o mesmo conjunto de operações de arquivo (`open()`, `read()`, `close()`) pode ser usado para interagir com processos, dispositivos de hardware, configurações do `kernel` e arquivos reais. Isso permite que ferramentas simples como `cat /proc/cpuinfo` ou `cat /proc/meminfo` forneçam informações do sistema sem necessidade de programas especializados. Por outro lado, o **Windows** oferece interfaces mais tipadas e estruturadas que podem ser mais eficientes e menos ambíguas, mas requerem conhecimento específico de cada API. 

O sistema de arquivo `/proc` é uma camada de abstração, a ativa leitora não estará lendo arquivos reais do disco, mas sim interfaces que o `kernel` gera dinamicamente na memória com dados que estão também na memória. Por exemplo, se a leitora executar `cat /proc/1234/status`, o `kernel` intercepta essa operação de leitura e constrói o conteúdo do arquivo em tempo real consultando suas estruturas internas de dados sobre aquele processo. Tecnicamente, `/proc` é classificado como um sistema de arquivos virtual,  pseudo sistema de arquivos, que existe apenas na memória `RAM`. O `kernel` mantém uma tabela de funções _callback_ que são executadas quando alguém tenta ler esses arquivos virtuais. Por exemplo, quando você lê `/proc/meminfo`, o `kernel` executa uma função específica que coleta estatísticas atuais de memória de suas estruturas de dados internas e formata essa informação como texto legível. Para deixar claro lembr-se que funções _callback são ponteiros para funções que são passados como parâmetros para outras funções e executados em momentos específicos durante a execução do programa_.

Esta abstração é poderosa porque permite que ferramentas existentes de manipulação de arquivos (`cat`, `grep`, `awk`, editores de texto) sejam usadas para inspecionar o estado do sistema sem precisar de `APIs`especiais. O custo computacional extra é mínimo, não há `E/S` de disco envolvido, apenas a conversão de estruturas binárias do `kernel` para representação textual na memória todo o custo está em converter o binário para texto no formato correto, movendo dados de um bloco de memória para outro. Quando nosso programa C++ faz `std::ifstream commFile("/proc/1234/comm")`, está realmente solicitando ao `kernel` que formate o nome do processo em um _string_ e a retorne através da interface familiar de arquivos.

Isso explica por que arquivos em `/proc` sempre mostram tamanho zero quando você executa `ls -l`. Estes arquivos não ocupam espaço em disco, existem apenas como pontos de entrada para funções do `kernel` que geram conteúdo sob demanda.

Ambas as abordagens têm vantagens: a interface textual do **Linux** é mais acessível para scripts e ferramentas de linha de comando, enquanto as `APIs`binárias do **Windows** oferecem mais performance e verificação de tipos em tempo de compilação. Os custos computacionais são diferentes, mas a verdadeira diferença está no público alvo: administradores de sistemas,  desenvolvedores de sistemas.
:::

Agora que a ansiosa leitora já sabe criar processos manualmente, precisamos entender o seu ciclo de vida. Já passamos pelo processo de gestão de processos, superficialmente na seção @sec-processos1. Na próxima seção, mergulharemos fundo.

### Clico de vida de um Processo

A capacidade de um **Sistema Operacional** de gerenciar múltiplos processos simultaneamente, que a atenta leitora deve chamar de multitarefa,  multiprograma, é a quilha que suporta toda a estrutura que permite que um usuário navegue na web enquanto ouve música, receba notificações por e-mail e escreva um livro sobre **Sistemas Operacionais**. Em sistemas com um único processador, essa simultaneidade é uma ilusão cuidadosamente orquestrada, denominada pseudo-paralelismo. O **Sistema Operacional** alterna a Unidade Central de Processamento, `CPU` entre vários processos em intervalos de tempo muito curtos, criando a percepção de que eles estão sendo executados em paralelo e ao mesmo tempo. Apenas em sistemas multiprocessador, o verdadeiro paralelismo é alcançado, com diferentes processos sendo executados em diferentes núcleos de `CPU` ao mesmo tempo.

Para gerenciar essa complexa dança de tarefas concorrentes, o **Sistema Operacional** abstrai o ciclo de vida de cada processo em um conjunto de estados discretos. Este é o mecanismo central pelo qual o **Sistema Operacional** aloca recursos, garante a justiça, impõe a proteção e mantém a estabilidade do sistema. a transição de um processo entre esses estados é um evento que dita quando um processo pode usar a `CPU`, quando deve esperar por recursos e quando deve ceder o controle.

Nesta parte da nossa jornada, iniciaremos explorando a evolução dos modelos teóricos, desde os mais simples até os mais complexos que incorporam o gerenciamento de memória virtual. Ao chegarmos o porto termos uma compreensão abrangente de como um processo nasce, vive e morre dentro do ecossistema de um **Sistema Operacional**.

### Modelos Teóricos do Ciclo de Vida do Processo

O modelo mais rudimentar do ciclo de vida de um processo é o **modelo de dois estados**. Neste modelo, um processo pode estar em apenas um de dois estados: ***Executando***, em inglês _Running_,  **Não-Executando**, em inglês _Not-running_. Quando o **Sistema Operacional** cria um novo processo, ele o coloca em uma fila no estado **Não-Executando**. Quando o processo em execução atual é pausado, o despachante, em inglês  _dispatcher_, do **Sistema Operacional** seleciona um processo da fila de **Não-Executando** e o move para o estado ***Executando***. Simples, limpo e fácil de implementar. Tudo que precisamos é olhar a fila e executar o processo que estiver há mais tempo como **Não-Executando**. Este modelo é adequado para sistemas muito simples, nos quais não exista necessidade de distinguir entre processos prontos para serem executados e aqueles que estão esperando por recursos externos, como Entrada/Saída, `E/S`. Talvez para um sistema embarcado.

A simplicidade deste modelo, no entanto, esconde uma falha fundamental que o torna inadequado para qualquer sistema de multitarefa real. O estado **Não-Executando** agrupa indiscriminadamente duas categorias de processos fundamentalmente diferentes: aqueles que estão prontos para serem executados e apenas aguardam a disponibilidade da `CPU`, e aqueles que estão bloqueados, esperando pela conclusão de uma operação de Entrada/Saída. Esta falta de distinção é problemática. O despachante não pode simplesmente selecionar o processo que está há mais tempo na fila de **Não-Executando**. Esse processo que está há mais tempo na fila pode estar bloqueado esperando por uma leitura de disco e, portanto, incapaz de utilizar a `CPU`. Escolher tal processo resultaria em desperdício de ciclos de `CPU` e em uma utilização ineficiente do sistema. A necessidade de um agendamento mais inteligente e eficiente impulsionou o desenvolvimento de modelos mais granulares. Um tanto mais complexos. A @fig-twoprocess representa esse modelo de dois estados.

::: {#fig-twoprocess}
![](images/modelo_dois_estados.webp)

Modelo de dois estados do ciclo de vida do processo mostrando uma representação da fila de processos **Não-Executando** e o processo **Executando**. O modelo de dois estados é simples, mas não distingue entre processos prontos e bloqueados, levando a ineficiências no agendamento.
:::

#### O Modelo Canônico de Cinco Estados

Para resolver as deficiências do modelo de dois estados, o estado **Não-Executando** foi dividido em dois novos estados: ***Pronto***, em inglês _Ready_ e ***Bloqueado***, _Blocked_. Essa separação é o avanço chave do **modelo de cinco estados**, que se tornou o modelo canônico para descrever o ciclo de vida de um processo na teoria dos **Sistemas Operacionais**. Este modelo, como vimos anteriormente na @sec-processos1 é composto pelos seguintes estados:

- **Novo (_New_)**: este é o estado inicial de um processo. O **Sistema Operacional** realizou as etapas preliminares para criar o processo, como a alocação de um identificador de processo (**PID**) e a criação de suas estruturas de dados internas, notadamente o Bloco de Controle de Processo (**PCB**). No entanto, o processo ainda não foi admitido no conjunto de processos que competem pela `CPU` e pode ainda não ter seu espaço de memória principal alocado.  

- **Pronto (_Ready_)**: um processo no estado **Pronto** está totalmente preparado para ser executado. Ele possui todos os recursos necessários, reside na memória principal e aguarda apenas uma oportunidade para ser alocado à `CPU` pelo agendador de tarefas, em inglês _scheduler_. Processos neste estado são mantidos em uma fila, comumente chamada de fila de prontos.

- **Executando (_Running_)**: neste estado, as instruções do processo estão sendo ativamente executadas pela `CPU`. Em um sistema com um único processador, apenas um processo pode estar no estado **Executando** a qualquer momento.  

- **Bloqueado/Esperando (_Blocked/Waiting_)**: um processo  transita para o estado **Bloqueado** quando não pode continuar sua execução, mesmo que a `CPU` esteja disponível. Isso ocorre porque ele precisa esperar por algum evento externo. Os exemplos mais comuns são a espera pela conclusão de uma operação de `E/S`, tais como ler dados de um disco ou receber um pacote de rede, a espera para adquirir um **semáforo** ou, o pior dos casos, a espera por um período de tempo específico.  

- **Terminado (Terminated/Exit)**: Este é o estado final de um processo. Ele chegou a este estado porque concluiu sua execução normal (e.g., chamando a função exit()) ou foi encerrado de forma anormal pelo **Sistema Operacional** devido a um erro irrecuperável ou a um comando externo. Neste ponto, o **Sistema Operacional** recupera todos os recursos que haviam sido alocados ao processo.

As transições entre esses estados são tão importantes quanto os próprios estados e são acionadas por eventos específicos gerenciados pelo Sistema Operacional:

- **Novo $\rightarrow$ Pronto (Admissão)**: o **Sistema Operacional**, por meio de seu agendador de longo ou médio prazo, decide admitir o processo recém-criado no conjunto de processos ativos. Isso geralmente envolve alocar a memória principal para o processo e colocar seu PCB na fila de prontos. Mantenha o foco, vamos falar destes agendadores diferentes em futuro próximo. Ainda neste capítulo.

- **Pronto $\rightarrow$ Executando (Despacho)**: o agendador de curto prazo,  agendador de `CPU` seleciona um processo da fila de prontos e aloca este processo à `CPU`. Esta ação é chamada de despacho, em inglês _dispatch_.  

- **Executando $\rightarrow$ Pronto (Preempção/Time t)**: a transição mais comum em sistemas de tempo compartilhado, veja a seção @sec-timesharing. O processo em execução é interrompido pelo **Sistema Operacional** e movido de volta para a fila de prontos. Isso pode ocorrer porque o processo esgotou sua fatia de tempo, chamada de _timeslice_ ou quantum, alocada,  um processo de prioridade mais alta tornou-se pronto para executar, chamamos isso de preempção.  

- **Executando $\rightarrow$ Bloqueado (Espera por Evento)**: o processo em execução inicia uma operação que não pode ser concluída imediatamente. Por exemplo, ele faz uma chamada de sistema para ler um arquivo. Como o processo não pode prosseguir até que os dados estejam disponíveis, o **Sistema Operacional** o move para o estado **Bloqueado** e agenda outro processo para execução.  

- **Bloqueado $\rightarrow$ Pronto (Ocorrência de Evento)**: O evento pelo qual o processo estava esperando finalmente ocorre. Por exemplo, a operação de `E/S` é concluída e o hardware gera uma interrupção. O **Sistema Operacional** processa a interrupção e move o processo correspondente da fila de bloqueados de volta para a fila de prontos, tornando-o novamente elegível para competir pela `CPU`.  

- **Executando $\rightarrow$ Terminado (Término)**: O processo finaliza sua tarefa e solicita ao **Sistema Operacional** para ser encerrado,  é forçadamente encerrado. Seus recursos são desalocados e ele deixa de existir como uma entidade ativa.

A @fig-cincoprocessos resume os estados e as transições do modelo de cinco estados. Este modelo é fundamental para entender como os **Sistemas Operacionais** modernos gerenciam a concorrência e a alocação de recursos.

::: {#fig-cincoprocessos}
![](images/modelo_cinco_estados.webp)

O diagrama ilustra os cinco estados fundamentais pelos quais um processo pode transitar durante sua execução: Novo (New), Pronto (Ready), Executando (Running), Bloqueado (Blocked/Waiting) e Terminado (Terminated). As setas indicam as transições possíveis entre estados, controladas pelos agendadores de longo prazo (long-term scheduler) e curto prazo (short-term scheduler/dispatcher). As filas de prontos e bloqueados representam as estruturas de dados utilizadas pelo **Sistema Operacional** para gerenciar processos em cada estado. Este modelo resolve as limitações do modelo de dois estados ao distinguir explicitamente processos prontos para execução daqueles aguardando eventos externos.
:::

#### Expandindo o Modelo: A Introdução de Estados Suspensos

O modelo de cinco estados, embora robusto, opera sob uma suposição implícita: todos os processos, sejam eles **Prontos** ou **Bloqueados**, residem na memória principal, a `RAM`. No entanto, a realidade do hardware introduz uma complicação. A velocidade da `CPU` é ordens de magnitude maior que a velocidade dos dispositivos de `E/S`, como os discos rígidos. Isso pode levar a um cenário de gargalo de `E/S`, no qual a maioria ou todos os processos na memória principal estão no estado **Bloqueado**, aguardando a conclusão de operações de `E/S`. Nesse ínterim, a `CPU` fica ociosa, e a memória principal, um recurso caro e limitado, fica ocupada por processos que não podem ser executados. Isso é mau, muito mau.

Para combater essa ineficiência e aumentar o grau de multiprogramação, o número de processos na memória, os **Sistemas Operacionais** introduziram o conceito de **swapping**, o termo em inglês para troca, e memória virtual. O sistema pode mover um processo inteiro,  partes dele, da memória principal para um armazenamento secundário mais lento, como o disco, liberando assim a `RAM` para outros processos. Esse ato de mover um processo para o disco é geralmente chamado de **suspensão**.

A introdução da suspensão torna o modelo de cinco estados inadequado, pois ele não consegue distinguir entre um processo que está pronto para executar e está na memória e um que está pronto para executar, mas foi movido para o disco. Para capturar essa nova dimensão, o **modelo de sete estados** foi desenvolvido, adicionando dois estados suspensos:

- **Bloqueado/Suspenso (Blocked/Suspended)**: Um processo que estava no estado **Bloqueado** (na memória principal, esperando por um evento) foi movido para o armazenamento secundário. Para que possa ser executado, ele precisa que duas condições sejam satisfeitas: o evento pelo qual estava esperando deve ocorrer, e ele deve ser trazido de volta para a memória principal.  

- **Pronto/Suspenso (Ready/Suspended)**: Um processo neste estado está pronto para ser executado, mas reside no armazenamento secundário. Ele pode ter chegado a este estado de duas maneiras: estava no estado **Pronto** e foi suspenso para liberar memória,  estava no estado **Bloqueado/Suspenso** e o evento que esperava ocorreu. A única barreira para sua execução é ser carregado de volta para a memória principal.

Este modelo mais complexo introduz um novo conjunto de transições, geralmente gerenciadas por um agendador de médio prazo:

- **Bloqueado → Bloqueado/Suspenso (Suspender)**: O **Sistema Operacional** seleciona um processo bloqueado e o move para o disco para liberar memória.  
- **Pronto → Pronto/Suspenso (Suspender)**: Menos comum, mas possível, o sistema pode suspender um processo pronto de baixa prioridade.  
- **Bloqueado/Suspenso → Pronto/Suspenso (Ocorrência de Evento)**: O evento que o processo esperava ocorre enquanto ele está no disco. Seu estado muda, mas ele permanece no armazenamento secundário.  
- **Pronto/Suspenso → Pronto (Ativar)**: O **Sistema Operacional** decide que há memória suficiente ou que o processo tem prioridade alta, e o move do disco de volta para a memória principal, colocando-o na fila de prontos.  
- **Novo → Pronto/Suspenso**: Um novo processo pode ser criado e imediatamente colocado no estado suspenso se não houver memória principal disponível no momento da criação.

A evolução do modelo de dois para o de sete estados não é um mero acréscimo de complexidade teórica. Ela demonstra como os modelos de gerenciamento de processos são moldados pelas realidades e limitações da arquitetura de hardware subjacente. Cada camada de complexidade no modelo de estados corresponde a uma solução de engenharia para um problema real de gerenciamento de recursos, primeiro, o problema de agendamento ineficiente, e depois, o problema do gargalo de `E/S` e da escassez de memória principal. Este modelo pode ser visto na @fig-seteestados.

::: {#fig-seteestados}
![](images/modelo_sete_estados.webp)

O diagrama ilustra a evolução do modelo canônico pela introdução de dois novos estados suspensos: Pronto/Suspenso (Ready/Suspended) e Bloqueado/Suspenso (Blocked/Suspended). A separação visual entre memória principal (RAM) e armazenamento secundário (disco) destaca o conceito fundamental do swapping. O agendador de médio prazo (medium-term scheduler) gerencia as operações de suspensão e ativação, movendo processos entre memória e disco para resolver o gargalo de `E/S`e aumentar o grau de multiprogramação. Este modelo permite que o **Sistema Operacional** mantenha mais processos ativos no sistema total, mesmo quando a memória principal é limitada, otimizando a utilização da `CPU` ao evitar que ela permaneça ociosa durante operações de `E/S`.
:::

